%\VignetteIndexEntry{Genetic Variant Annotation}
%\VignetteDepends{GenomicRanges, Rsamtools, Biostrings}
%\VignetteKeywords{variants, sequence, sequencing, alignments}
%\VignettePackage{VariantAnnotation}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\VariantAnnotation}{\Rpackage{VariantAnnotation}}

\title{Annotation of Genetic Variants with \VariantAnnotation}
\author{Valerie Obenchain and Michael Lawrence}
\date{\today}

\begin{document} 

\maketitle

<<options, echo=FALSE>>=
options(width=72)
@

\section{Introduction}
In this vignette we illustrate the annotation and filtering of genetic 
variants with the \VariantAnnotation  package. Location with respect to 
gene function is provided as well as amino acid coding for non-synonymous 
variants. Filters are available for identifying subsets of variants based 
on criteria such as inclusion in dbSNP, 1000 Genomes, and SIFT scores
(work in progress ...). 

\section{Location with respect to gene function}
As sample data we use the \Robject{GRanges} object, \Robject{variants},
that contains both real and faux variants. The ranges in \Robject{variants} 
represent the position of the variant. A single basepair replacement
(SNP) has equal start and end positions and a width of length 1. A deletion 
or substitution will have a width of 1 or greater depending on the number of 
basepairs being deleted or substituted. Insertions are represented with the 
start position one less than the end which results in a width of length 0. 

The reference and variant alleles are contained in the \Robject{refAllele} and 
\Robject{varAllele} columns as \Robject{DNAStringSet}s. An insertion 
will have a missing value in the \Robject{refAllele} column and a deletion
will have a missing value in the \Robject{varAllele} column.
 
<<data>>=
library(VariantAnnotation)
data(variants)
head(variants)
@

The \Rfunction{locateVariants} function returns a \Robject{DataFrame} with
one row for each variant-transcript match. Transcript ID, gene ID and location 
are provided for each match. The queryIndex column maps back to the variant
in the original query. Location categories of `coding', `UTR5', `UTR3', `intron' 
and `intergenic' are assigned based on the criteria in Table \ref{table:location}. 
Intergenic variants have two gene ID's, representing the closest genes on either
side of the variant. 

<<location>>=
library(TxDb.Hsapiens.UCSC.hg18.knownGene)
txdb <- Hsapiens_UCSC_hg18_knownGene_TxDb
loc <- locateVariants(variants, txdb)
head(loc)
@


\begin{table}[ht]
\begin{center}
\begin{tabular}{c|l}
\hline
Region & Details \\
\hline
coding &  variant falls \emph{within} a coding region \\
%splicing & * & variant is within 2-bp of a splicing junction \\
%ncRNA & 2 & variant overlaps a transcript without coding annotation in the gene
%definition \\
UTR5 &  variant overlaps \emph{any} portion of a 5' untranslated region \\
UTR3 &  variant overlaps \emph{any} portion of a 3' untranslated region \\
intron &  variant overlaps \emph{any} portion of a transcript but does not
fall \emph{within} a coding region \\
%upstream & 5 &  variant overlaps 1-kb region upstream of transcription start
%site \\
%downstream & 5 & variant overlaps 1-kb region downtream of transcription end
%site \\
intergenic & variant does not overlap \emph{any} portion of a transcript \\
\hline
\end{tabular}
\end{center}
\caption{Variant Location}
\label{table:location}
\end{table}

Example of a snp from chromosome 16 in hg18 dbSNP file aligned to 
different chromosome locations for different assemblies. Each alignment is 
entered as a separate row in the \Rcode{singleSNP} object. 

<<singleSNP>>=
singleSNP <- GRanges(seqnames="chr16",
        ranges=IRanges(start=c(23004226, 22316999, 24133766),
               width=c(1,1,1)),
        refAllele=DNAStringSet("A"), varAllele=DNAStringSet("T"),
        comments=c("Celera assembly", "HuRef assembly", "reference assembly"))

singleSNP
@

The result from \Rfunction{locateVariants} shows the Celera assembly
location matching two transcripts in the same gene, both intron regions.
The HuRef assembly location falls in an intergenic region. The reference
assembly location hits two different transcripts in the same gene, both
in the 3' UTR region. 
<<singleSNPresult>>=
locateVariants(singleSNP, txdb)
@

\section{Amino Acid Coding Changes}

Amino acid coding changes can be determined for non-synonymous
variants with \Rfunction{predictCoding}. This function identifies overlaps 
between the variants in the \Robject{query} and the coding 
regions of a \Robject{TranscriptDb} object. Sequences for the reference 
codons are retrieved from either a \Robject{BSgenome} or fasta file. Codons 
sequences for the variants are produced by substituting, inserting or deleting 
the \Robject{varAllele} values into the reference sequences. Amino acid codes 
are computed for the resulting variant codon sequence when the length is a 
multiple of 3. Examples of various coding situations are shown in Table 
\ref{table:aacoding}. Positions of substitution, insertion or deletion in Table 
\ref{table:aacoding} are purely random and were chosen for example purposes only.

\begin{table}[ht]
\begin{center}
\begin{tabular}{c|c|c|c|c|c}
\hline
Type & refAllele & varAllele & refCodon & varCodon & AA coding of varCodon  \\
\hline
substitution & G & T & aag & aaT & yes\\
substitution & G & TG & tga & tTGa & no\\
substitution & G & TGCG & gtc & TGCGtc & yes\\
insertion & `' & G & cgg & Gcgg & no\\
insertion & `' & TTG & gaa & gaTTGa & yes\\
deletion & A & `' & atc & tc & no\\
deletion & GGCCTA & `' & acggcctaa & aca & yes\\
\hline
\end{tabular}
\end{center}
\caption{Amino Acid Coding}
\label{table:aacoding}
\end{table}

The variants that fall within coding regions are in chromosomes 1, 2 and 16. 
Here we create a \Robject{GRanges} of coding regions by transcripts and 
retain only the chromosomes of interest for the \Robject{subject}. Alternatively 
we could have used the full \Robject{TranscriptDb}.

<<aacoding>>=
library(BSgenome.Hsapiens.UCSC.hg18)
cdsByTx <- cdsBy(txdb)
grl <- keepSeqlevels(cdsByTx, c("chr1", "chr2", "chr16"))

aaCoding <- predictCoding(variants, grl, seqSource=Hsapiens,
    refAllele="refAllele", varAllele="varAllele")
head(aaCoding)
@

Our result is a \Robject{DataFrame} containing only the variants that
matched a coding region. Columns include queryIndex, 
txID, refCodon, varCodon, refAA, varAA, Consequence and any
metadata columns that were present in the \Robject{subject}. 

The result has one row for each transcript matched by a variant. The
queryIndex column is the map back to the variants in the original \Robject{query}.
If a variant matches multiple transcripts there will be multiple rows
for that variant. For example, the variant in the sixth row of the 
\Robject{variants} object fell within a coding region and matched four transcripts. 
The first four rows of the aaCoding result are the data for this variant.

The Consequence column indicates `synonymous' or `nonsynonymous' for 
variants for which the codons could be translated. If translation was not 
possible the Consequence was considered a `frameshift'. Variants for which no 
amino acid codes were computed have a missing in value in the varAA column. 
<<aacodingResultOneVariant>>= 
aaCoding[width(aaCoding$varAA) == 0,] 
@


\section{Filtering Variants}

Identifying subsets of variants that meet a specific criteria can be
accomplished with the filter functions in the \Rpackage{VariantAnnotaion} package.
Currenty there is support for filtering based on location (e.g., coding, intron,
5' utr, etc.) and for presence/absence of the variant in dbSNP.

investigating : \\
- SIFT \\
- polyphen \\
- 1000 genomes \\
- HapMap \\
- conservation regions \\ 

<<filtering>>=
# variants present in dbSNP 
snpFilt <- dbSNPFilter("SNPlocs.Hsapiens.dbSNP.20090506")
snpFilt(variants)

# variants present in coding regions 
regionFilt <- regionFilter(txdb, region="coding")
regionFilt(variants)

# both filters as a single filter
combofilt <- compose(snpFilt, regionFilt)
combofilt(variants)

## both filters as a collection
#colfilt <- c(snpfilt, regfilt)
#subsetByFilter(variants, colfilt)
#summary(colfilt, variants)
@

%Region-based annotations are used to identify variants at conserved genomic regions.
%Overlaps between the variants and a user-specified conservation track are provided. 
%Region Based : \\
%Annotate genome elements other than genes. This is especially 
%important for whole genome sequencing data as the vast majority of 
%variants will be outside of protein encoding regions and their 
%function effects cannot be assessed by gene-based annotations.
%The following types of regions may be useful to annotate,\\
%- conserved genomic\\
%- predicted transcription factor binding sites\\
%- predicted RNA secondary structures\\
%

\section{References}
Wang K, Li M, Hakonarson H, (2010), ANNOVAR: functional annotation of genetic 
variants from high-throughput sequencing data. Nucleic Acids Research, Vol 38,
No. 16, e164.\\

\noindent McLaren W, Pritchard B, RiosD, et. al., (2010), Deriving the consequences of
genomic variants with the Ensembl API and SNP Effect Predictor. Bioinformatics,
Vol. 26, No. 16, 2069-2070.

%\section{Session Information}
%<<sessionInfo>>=
%sessionInfo()
%@

\end{document}
