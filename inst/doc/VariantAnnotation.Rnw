%\VignetteIndexEntry{Introduction to VariantAnnotation}
%\VignetteDepends{GenomicRanges, Rsamtools, Biostrings}
%\VignetteKeywords{variants, sequence, sequencing, alignments}
%\VignettePackage{VariantAnnotation}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\VariantAnnotation}{\Rpackage{VariantAnnotation}}

\title{Introduction to \VariantAnnotation}
\author{Valerie Obenchain, Michael Lawrence}
\date{\today}

\begin{document} 

\maketitle

<<options, echo=FALSE>>=
options(width=72)
@

\section{Introduction}
In this vignette we introduce methods in the \VariantAnnotation
package for the annotation and filtering of genetic variants. Functions are 
available for identifying location with respect to gene function as well as 
amino acid coding changes for variants that fall in coding regions. 
Variants can be subset on location and for presence in dbSNP 
with the built-in filters. Additionally, a function for reading in Variant Call Format 
(VCF) files into a \Robject{SummarizedExperiment} object is provided. 

\section{Variant Location}
As sample data we use the \Robject{GRanges} object, \Robject{variants},
that contains both real and faux variants. The ranges in \Robject{variants} 
represent the positions in the reference sequence that are altered in the
variation. A single basepair replacement
(SNP) has equal start and end positions and a width of length 1. A deletion 
or substitution will have a width of 1 or greater depending on the number of 
basepairs being deleted or substituted. Insertions are represented with 
start = end + 1 which results in a width of length 0. 

The reference and variant alleles are contained in the \Robject{refAllele} and 
\Robject{varAllele} columns as \Robject{DNAStringSet}s. An insertion 
will have a missing value in the \Robject{refAllele} column and a deletion
will have a missing value in the \Robject{varAllele} column.
 
<<data>>=
library(VariantAnnotation)
data(variants)
head(variants)
@

\Rfunction{locateVariants} returns a \Robject{DataFrame} with
one row for each variant-transcript match. Transcript ID, gene ID and location 
are provided for each match. The queryHits column maps back to the variant
in the original query. Location categories of `coding', `UTR5', `UTR3', `intron' 
and `intergenic' are assigned based on the criteria in Table \ref{table:location}. 
Intergenic variants have two gene ID's, representing the genes preceding and following
the variant. 

<<location>>=
library(TxDb.Hsapiens.UCSC.hg18.knownGene)
txdb <- Hsapiens_UCSC_hg18_knownGene_TxDb
loc <- locateVariants(variants, txdb)
head(loc)
@

\begin{table}[ht]
\begin{center}
\begin{tabular}{c|l}
\hline
Region & Details \\
\hline
coding &  variant falls \emph{within} a coding region \\
%splicing & * & variant is within 2-bp of a splicing junction \\
%ncRNA & 2 & variant overlaps a transcript without coding annotation in the gene
%definition \\
UTR5 &  variant falls \emph{within} a 5' untranslated region \\
UTR3 &  variant falls \emph{within} a 3' untranslated region \\
intron &  variant falls \emph{within} a transcript but not
\emph{within} a coding region \\
%upstream & 5 &  variant overlaps 1-kb region upstream of transcription start
%site \\
%downstream & 5 & variant overlaps 1-kb region downtream of transcription end
%site \\
intergenic & variant does not fall \emph{within} a transcript \\
\hline
\end{tabular}
\end{center}
\caption{Variant Location}
\label{table:location}
\end{table}

Multiple alignments for a single variant should be entered as separate rows in
the \Rcode{query} object. Below is an example snp from the Build 130 dbSNP 
file which is aligned to different locations for different assemblies. Each 
alignment is entered as a separate row in the \Rcode{singleSNP} object. 

<<singleSNP>>=
singleSNP <- GRanges(seqnames="chr16",
        ranges=IRanges(start=c(23004226, 22316999, 24133766),
               width=c(1,1,1)),
        varAllele=DNAStringSet("T"),
        comments=c("Celera assembly", "HuRef assembly", "reference assembly"))

singleSNP
@

The result from \Rfunction{locateVariants} shows the Celera assembly
location matching two transcripts in the same gene, both intron regions.
The HuRef assembly location falls in an intergenic region. The reference
assembly location hits two different transcripts in the same gene, both
in the 3' UTR region. 
\begin{verbatim}
> locateVariants(singleSNP, txdb)
DataFrame with 5 rows and 4 columns
  queryHits        txID                    geneID    Location
  <integer> <character> <CompressedCharacterList> <character>
1         1       52091                     57478      intron
2         1       52092                     57478      intron
3         2          NA                1039,57478  intergenic
4         3       50256                      5579       3'UTR
5         3       50259                      5579       3'UTR
\end{verbatim}

\section{Amino Acid Coding}

Amino acid coding changes can be determined for non-synonymous
variants with \Rfunction{predictCoding}. This function identifies overlaps 
between the variants in the \Robject{query} and the coding 
regions of a \Robject{TranscriptDb} object. Sequences for the reference 
codons are retrieved from either a \Robject{BSgenome} or fasta file. Codons 
sequences for the variants are produced by substituting, inserting or deleting 
the \Robject{varAllele} values into the reference sequences. Amino acid codes 
are computed for the resulting variant codon sequence when the length is a 
multiple of 3. Examples of various coding situations are shown in Table 
\ref{table:aacoding}. Positions of substitution, insertion or deletion in Table 
\ref{table:aacoding} are purely random and were chosen for example purposes only.

\begin{table}[ht]
\begin{center}
\begin{tabular}{c|c|c|c|c|c}
\hline
Type & refAllele & varAllele & refSeq & varSeq & AA coding of varSeq  \\
\hline
substitution & G & T & aag & aaT & yes\\
substitution & G & TG & tga & tTGa & no\\
substitution & G & TGCG & gtc & TGCGtc & yes\\
insertion & `' & G & cgg & Gcgg & no\\
insertion & `' & TTG & gaa & gaTTGa & yes\\
deletion & A & `' & atc & tc & no\\
deletion & GGCCTA & `' & acggcctaa & aca & yes\\
\hline
\end{tabular}
\end{center}
\caption{Amino Acid Coding}
\label{table:aacoding}
\end{table}

The variants that fall within coding regions are in chromosomes 1, 2 and 16. 
Here we create a \Robject{GRanges} of coding regions by transcripts and 
retain only the chromosomes of interest for the \Robject{subject}. Alternatively 
we could have used the full \Robject{TranscriptDb}.

<<aacoding>>=
library(BSgenome.Hsapiens.UCSC.hg18)
cdsByTx <- cdsBy(txdb)
grl <- keepSeqlevels(cdsByTx, c("chr1", "chr2", "chr16"))

aaCoding <- predictCoding(variants, grl, seqSource=Hsapiens,
    varAllele="varAllele")
head(aaCoding)
@

Our result is a \Robject{DataFrame} containing only the variants that
fell within a coding region. Columns include queryHits, 
txID, refSeq, varSeq, refAA, varAA, Consequence and any
metadata columns that were present in the \Robject{subject}. 

The result has one row for each transcript matched by a variant. The
queryHits column is the map back to the variants in the original \Robject{query}.
If a variant matches multiple transcripts,  multiple rows are returned
for that variant. For example, the variant in the sixth row of the 
\Robject{variants} object fell within a coding region and matched four transcripts. 
The first four rows of the aaCoding result are the data for this variant.

The Consequence column indicates `synonymous' or `nonsynonymous' for 
variants for which the codons could be translated. If translation was not 
possible the Consequence was considered a `frameshift'. Variants for which no 
amino acid codes were computed have a missing in value in the varAA column. 
<<aacodingResultOneVariant>>= 
aaCoding[width(aaCoding$varAA) == 0,] 
@


\section{Filtering Variants}

Identifying subsets of variants that meet a specific criteria can be
accomplished using the filter functions provided in \Rpackage{VariantAnnotation}.
Filters are first created with the appropriate reference object needed to construct the 
filter, either a dbSNP package or \Robject{TranscriptDb} object. 

<<createFilters>>=
library("SNPlocs.Hsapiens.dbSNP.20090506")
## create filter to identify variants present in dbSNP 
snpFilt <- dbSNPFilter("SNPlocs.Hsapiens.dbSNP.20090506")

## create filter to identify variants present in introns 
regionFilt <- regionFilter(txdb, region="intron")
regionFilt
@

When applying a filter to the data, the optional argument \Rcode{subset}
can be specified. If \Rcode{subset=TRUE} (the default), the subset of 
records that passed the filter are returned in a \Rcode{GRanges} object. 
The filter name and number of records filtered are included in the object 
metadata. When \Rcode{subset=FALSE} a \Robject{VAFilterResult} object is 
returned which contains a logical vector indicating which records passed the filter.

<<filtering>>=
## return the subset of records that passed the filter
snpResult <- snpFilt(variants)
snpResult 
metadata(snpResult)

## return a VAFilterResult object
snpFilt(variants, subset=FALSE)
@

Filters can be combined to act in unison,
\begin{verbatim}
# return a subset of data passing both filters
> combofilt <- compose(snpFilt, regionFilt)
> combofilt(variants)
region= intron 
GRanges with 2 ranges and 3 elementMetadata values
    seqnames                 ranges strand |      refAllele      varAllele
       <Rle>              <IRanges>  <Rle> | <DNAStringSet> <DNAStringSet>
[1]     chr1 [161003087, 161003087]      * |              C              T
[2]     chr1 [ 84647761,  84647761]      * |              C              T
          comments
       <character>
[1] rs1000050, SNP
[2]  rs6576700 SNP

seqlengths
  chr1 chr13 chr16  chr2
    NA    NA    NA    NA
\end{verbatim}


\section{Variant Call Format (VCF) files}

The \Rcode{readVcf} function reads VCF files into a 
\Rcode{SummarizedExperiment} object. If the compressed VCF file
has a tabix file index, a \Robject{GRanges} can be used to specify 
a subset of ranges to read in. We don't have a sample compressed VCF file
in \Rcode{VariantAnnotation} so we create one on the fly as a temporary file.
We then create a tabix index for the file and retrieve a subset of ranges
restricted by those specified in the \Rcode{GRanges} object. 

<<readVCF>>=
## compress vcf file , create index
vcfFile <- system.file("extdata", "ex1.vcf", package="VariantAnnotation")
from <- vcfFile
to <- tempfile()
compressVcf <- bgzip(from, to)
idx <- indexTabix(compressVcf, "vcf")
tab <- TabixFile(compressVcf, idx)
head <- headerTabix(tab)

## range restriction 
gr <- GRanges(seqnames="1",
              ranges=IRanges(start=0, end=100000))
@


The VCF standard is to include the nucleotide immediately preceding 
an indel in the reference sequence. This results in the start
location being one less than the position where the variation
(i.e., substitution, insertion, or deletion) takes place.
When \Rcode{vcfRanges = TRUE}, the ranges and alleles in the
\Rcode{SummarizedExperiment} are returned exactly as they
appear in the VCF file. 

<<readVCF_vcfRangesTRUE>>=
## return alleles and ranges exactly as represented in the VCF file
original <- readVcf(tab, param=gr, vcfRanges=TRUE)
@ 

When \Rcode{vcfRanges = FALSE}, additional ranges are supplied
that conform to the \Rcode{Bioconductor} standards for representing ranges.
Additionally, the alleles are modified to retain only 
the basepairs involved in the variation. These modifications
are made to provide compatibility with existing methods. 
The modified ranges are in a \Rcode{DataFrame} in 
the `ALT' field of the metadata. 

<<readVCF_vcfRangesFALSE>>=
modified <- readVcf(tab, param=gr, vcfRanges=FALSE)

## compare reference alleles 
cbind(as.character(values(rowData(original))[["ref"]]), 
    as.character(values(rowData(modified))[["ref"]]))
@

\section{References}
Wang K, Li M, Hakonarson H, (2010), ANNOVAR: functional annotation of genetic 
variants from high-throughput sequencing data. Nucleic Acids Research, Vol 38,
No. 16, e164.\\

\noindent McLaren W, Pritchard B, RiosD, et. al., (2010), Deriving the consequences of
genomic variants with the Ensembl API and SNP Effect Predictor. Bioinformatics,
Vol. 26, No. 16, 2069-2070.

\section{Session Information}
<<sessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
