%\VignetteIndexEntry{Genetic Variant Annotation}
%\VignetteDepends{GenomicRanges, Rsamtools, Biostrings}
%\VignetteKeywords{variants, sequence, sequencing, alignments}
%\VignettePackage{VariantAnnotation}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\VariantAnnotation}{\Rpackage{VariantAnnotation}}

\title{Annotation of Genetic Variants with \VariantAnnotation}
\author{Valerie Obenchain and Michael Lawrence}
\date{\today}

\begin{document} 

\maketitle

<<options, echo=FALSE>>=
options(width=72)
@

\section{Introduction}
In this vignette we illustrate the annotation and filtering of genetic 
variants with the \VariantAnnotation  package. Location with respect to 
gene function is provided as well as amino acid coding for non-synonymous 
variants. A variety of filters are available
for identifying subsets of variants based on criteria such as inclusion in 
dbSNP, 1000 Genomes, and SIFT scores. 

\section{Location with respect to gene function}
As sample data we use the \Robject{GRanges} object, \Robject{variants},

that contains both real and faux variants. The ranges in the \Robject{variants} 
object represent the position of the variant.
A SNP is represented with equal start and end positions and 
has a width of length 1. A deletion or substitution will have a width of 1 or
greater depending on the number of basepairs being deleted or substituted.
Insertions are represented with the start position one less than the end 
which results in a width of length 0. 

The reference and variant alleles are contained in the \Robject{refAllele} and 
\Robject{varAllele} columns as \Robject{DNAStringSet}s. An insertion 
will have a missing value in the \Robject{refAllele} column and a deletion
will have a missing value in the \Robject{varAllele} column.
 
<<data>>=
library(VariantAnnotation)
data(variants)
head(variants)
@

The \Rfunction{locateVariants} function returns a \Robject{DataFrame} with
location, transript ID and gene ID information. For intergenic variants, 
ID's for genes on either side of the variant are provided. At least one
row will be returned for each variant. When a variant matches multiple 
transcripts, a row is returned for each match.

<<location>>=
library(TxDb.Hsapiens.UCSC.hg18.knownGene)
txdb <- Hsapiens_UCSC_hg18_knownGene_TxDb
loc <- locateVariants(variants, txdb)
head(loc)
@

Location categories of `coding', `UTR5', `UTR3', `intron' and
`intergenic' are assigned based on the criteria in Table \ref{table:location}. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{c|l}
\hline
Region & Details \\
\hline
coding &  variant falls \emph{within} a coding region \\
%splicing & * & variant is within 2-bp of a splicing junction \\
%ncRNA & 2 & variant overlaps a transcript without coding annotation in the gene
%definition \\
UTR5 &  variant overlaps \emph{any} portion of a 5' untranslated region \\
UTR3 &  variant overlaps \emph{any} portion of a 3' untranslated region \\
intron &  variant overlaps \emph{any} portion of a transcript but does not
fall \emph{within} a coding region \\
%upstream & 5 &  variant overlaps 1-kb region upstream of transcription start
%site \\
%downstream & 5 & variant overlaps 1-kb region downtream of transcription end
%site \\
intergenic & variant does not overlap \emph{any} portion of a transcript \\
\hline
\end{tabular}
\end{center}
\caption{Variant Location}
\label{table:location}
\end{table}

Here is an example of a snp that was aligned to different chromosome locations
for different assemblies. 

<<singleSNP>>=
singleSNP <- GRanges(seqnames="chr16",
        ranges=IRanges(start=c(23004226, 22316999, 24133766),
               width=c(1,1,1)),
        refAllele=DNAStringSet("A"), varAllele=DNAStringSet("T"),
        comments=c("Celera assembly", "HuRef assembly", "reference assembly"))

locateVariants(singleSNP, txdb)
@

\section{Amino Acid Coding Changes}

The \Rfunction{predictCoding} function identifies overlaps 
between the variants in the \Robject{query} and the coding 
regions of a \Robject{TranscriptDb} object. Reference sequences 
for the codons are retrieved from either a \Robject{BSgenome} 
or fasta file. Codons sequences for the variants are produced by substituting,
inserting or deleting the alleles specified in the varAllele column
into the reference sequences. When the resulting variant codon sequence 
is a multiple of 3, amino acid codes are computed for the codon sequence. 
Table \ref{table:aacoding} shows examples of when amino acid codes are and 
are not computed for the variant codon sequence. Positions of substitution,
insertion or deletion in Table \ref{table:aacoding} are random and were chosen 
for example purposes only.

\begin{table}[ht]
\begin{center}
\begin{tabular}{c|c|c|c|l}
\hline
refAllele & varAllele & refCodon & varCodon & AA coding of varCodon  \\
\hline
G & T & agg & agT & yes, snp substitution result is multiple of 3\\
G & TG & tga & tTGa & no, substitution result is not multiple of 3\\
G & TGCG & gtc & TGCGtc & yes, substitution result is multiple of 3\\
`' & G & cgg & Gcgg & no, insertion result is not multiple of 3\\
`' & TTG & ttg & TttgTG & yes, insertion result is multiple of 3\\
A & `' & atc & tc & no, deletion result is not multiple of 3\\
GGCCTA & `' & acggcctaa & aca & yes, deletion result is multiple of 3\\
\hline
\end{tabular}
\end{center}
\caption{Amino Acid Coding}
\label{table:aacoding}
\end{table}

The variants that fall in coding regions are in chromosomes 1, 2 and 16. 
Here we create a \Robject{GRanges} of coding regions by transcripts and 
retain only the chromosomes of interest. Alternatively we could have used 
the full \Robject{TranscriptDb} as the \Robject{subject}.

<<aacoding>>=
library(BSgenome.Hsapiens.UCSC.hg18)
cdsByTx <- cdsBy(txdb)
grl <- keepSeqlevels(cdsByTx, c("chr1", "chr2", "chr16"))

aaCoding <- predictCoding(variants, grl, seqSource=Hsapiens,
    refAllele="refAllele", varAllele="varAllele")
head(aaCoding)
@

Our result is a \Robject{DataFrame} containing only the variants that
matched a coding region. Columns include queryIndex, 
txID, refCodon, varCodon, refAA, varAA, Consequence and any
metadata columns that were present in the \Robject{subject}. 

The result has one row for each transcript matched by a variant. The
queryIdx column is the map back to the rows in the original \Robject{query}.
If a variant matches multiple transcripts there will be multiple rows
for that variant. For example, the variant in the sixth row of the 
\Robject{variants} object fell within a coding region and matched four transcripts. 
The first four rows of the aaCoding result are the data for this variant.

The Consequence column indicates `synonymous' or `nonsynonymous' for 
variants for which the codons could be translated. If translation was not 
possible the Consequence was considered a `frameshift'. Variants for which no 
amino acid codes were computed have a missing in value in the varAA column. 
<<aacodingResultOneVariant>>= 
aaCoding[width(aaCoding$varAA) == 0,] 
@


\section{Filtering Variants}

Identifying subsets of variants that meet a specific criteria can be
accomplished with the filter functions in the \Rpackage{VariantAnnotaion} package.
Currenty there is support for filtering based on location (e.g., coding, intron,
5' utr, etc.) and for presence/absence of the variant in dbSNP.

investigating : \\
- SIFT \\
- polyphen \\
- 1000 genomes \\
- HapMap \\
- conservation regions \\ 

<<filtering>>=
# variants present in dbSNP 
snpFilt <- dbSNPFilter("SNPlocs.Hsapiens.dbSNP.20090506")
snpFilt(variants)

# variants present in coding regions 
regionFilt <- regionFilter(txdb, region="coding")
regionFilt(variants)

# both filters as a single filter
combofilt <- compose(snpFilt, regionFilt)
combofilt(variants)

## both filters as a collection
#colfilt <- c(snpfilt, regfilt)
#subsetByFilter(variants, colfilt)
#summary(colfilt, variants)
@

%Region-based annotations are used to identify variants at conserved genomic regions.
%Overlaps between the variants and a user-specified conservation track are provided. 
%Region Based : \\
%Annotate genome elements other than genes. This is especially 
%important for whole genome sequencing data as the vast majority of 
%variants will be outside of protein encoding regions and their 
%function effects cannot be assessed by gene-based annotations.
%The following types of regions may be useful to annotate,\\
%- conserved genomic\\
%- predicted transcription factor binding sites\\
%- predicted RNA secondary structures\\
%

\section{References}
Wang K, Li M, Hakonarson H, (2010), ANNOVAR: functional annotation of genetic 
variants from high-throughput sequencing data. Nucleic Acids Research, Vol 38,
No. 16, e164.\\

\noindent McLaren W, Pritchard B, RiosD, et. al., (2010), Deriving the consequences of
genomic variants with the Ensembl API and SNP Effect Predictor. Bioinformatics,
Vol. 26, No. 16, 2069-2070.

%\section{Session Information}
%<<sessionInfo>>=
%sessionInfo()
%@

\end{document}
