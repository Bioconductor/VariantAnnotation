%\VignetteIndexEntry{Introduction to VariantAnnotation}
%\VignetteDepends{GenomicRanges, Rsamtools, Biostrings}
%\VignetteKeywords{variants, sequence, sequencing, alignments}
%\VignettePackage{VariantAnnotation}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\VariantAnnotation}{\Rpackage{VariantAnnotation}}

\title{Introduction to \VariantAnnotation}
\author{Valerie Obenchain and Michael Lawrence}
\date{\today}

\begin{document} 

\maketitle

<<options, echo=FALSE>>=
options(width=72)
@

\section{Introduction}
In this vignette we illustrate the annotation and filtering of genetic 
variants with the \VariantAnnotation  package. Location with respect to 
gene function is provided as well as amino acid coding for non-synonymous 
variants. Filters are available for subsetting variants based 
on location and inclusion in dbSNP. 
(PolyPhen, SIFT, 1000 Genomies work in progress ...). 

\section{Location with respect to gene function}
As sample data we use the \Robject{GRanges} object, \Robject{variants},
that contains both real and faux variants. The ranges in \Robject{variants} 
represent the position of the variant. A single basepair replacement
(SNP) has equal start and end positions and a width of length 1. A deletion 
or substitution will have a width of 1 or greater depending on the number of 
basepairs being deleted or substituted. Insertions are represented with 
start = end - 1 which results in a width of length 0. 

The reference and variant alleles are contained in the \Robject{refAllele} and 
\Robject{varAllele} columns as \Robject{DNAStringSet}s. An insertion 
will have a missing value in the \Robject{refAllele} column and a deletion
will have a missing value in the \Robject{varAllele} column.
 
<<data>>=
library(VariantAnnotation)
data(variants)
head(variants)
@

The \Rfunction{locateVariants} function returns a \Robject{DataFrame} with
one row for each variant-transcript match. Transcript ID, gene ID and location 
are provided for each match. The queryHits column maps back to the variant
in the original query. Location categories of `coding', `UTR5', `UTR3', `intron' 
and `intergenic' are assigned based on the criteria in Table \ref{table:location}. 
Intergenic variants have two gene ID's, representing the genes preceding and following
the variant. 

<<location>>=
library(TxDb.Hsapiens.UCSC.hg18.knownGene)
txdb <- Hsapiens_UCSC_hg18_knownGene_TxDb
loc <- locateVariants(variants, txdb)
head(loc)
@


\begin{table}[ht]
\begin{center}
\begin{tabular}{c|l}
\hline
Region & Details \\
\hline
coding &  variant falls \emph{within} a coding region \\
%splicing & * & variant is within 2-bp of a splicing junction \\
%ncRNA & 2 & variant overlaps a transcript without coding annotation in the gene
%definition \\
UTR5 &  variant overlaps \emph{any} portion of a 5' untranslated region \\
UTR3 &  variant overlaps \emph{any} portion of a 3' untranslated region \\
intron &  variant overlaps \emph{any} portion of a transcript but does not
fall \emph{within} a coding region \\
%upstream & 5 &  variant overlaps 1-kb region upstream of transcription start
%site \\
%downstream & 5 & variant overlaps 1-kb region downtream of transcription end
%site \\
intergenic & variant does not overlap \emph{any} portion of a transcript \\
\hline
\end{tabular}
\end{center}
\caption{Variant Location}
\label{table:location}
\end{table}

Example of a snp from chromosome 16 in hg18 dbSNP file aligned to 
different chromosome locations for different assemblies. Each alignment is 
entered as a separate row in the \Rcode{singleSNP} object. 

<<singleSNP>>=
singleSNP <- GRanges(seqnames="chr16",
        ranges=IRanges(start=c(23004226, 22316999, 24133766),
               width=c(1,1,1)),
        varAllele=DNAStringSet("T"),
        comments=c("Celera assembly", "HuRef assembly", "reference assembly"))

singleSNP
@

The result from \Rfunction{locateVariants} shows the Celera assembly
location matching two transcripts in the same gene, both intron regions.
The HuRef assembly location falls in an intergenic region. The reference
assembly location hits two different transcripts in the same gene, both
in the 3' UTR region. 
<<singleSNPresult>>=
locateVariants(singleSNP, txdb)
@

\section{Amino Acid Coding Changes}

Amino acid coding changes can be determined for non-synonymous
variants with \Rfunction{predictCoding}. This function identifies overlaps 
between the variants in the \Robject{query} and the coding 
regions of a \Robject{TranscriptDb} object. Sequences for the reference 
codons are retrieved from either a \Robject{BSgenome} or fasta file. Codons 
sequences for the variants are produced by substituting, inserting or deleting 
the \Robject{varAllele} values into the reference sequences. Amino acid codes 
are computed for the resulting variant codon sequence when the length is a 
multiple of 3. Examples of various coding situations are shown in Table 
\ref{table:aacoding}. Positions of substitution, insertion or deletion in Table 
\ref{table:aacoding} are purely random and were chosen for example purposes only.

\begin{table}[ht]
\begin{center}
\begin{tabular}{c|c|c|c|c|c}
\hline
Type & refAllele & varAllele & refSeq & varSeq & AA coding of varSeq  \\
\hline
substitution & G & T & aag & aaT & yes\\
substitution & G & TG & tga & tTGa & no\\
substitution & G & TGCG & gtc & TGCGtc & yes\\
insertion & `' & G & cgg & Gcgg & no\\
insertion & `' & TTG & gaa & gaTTGa & yes\\
deletion & A & `' & atc & tc & no\\
deletion & GGCCTA & `' & acggcctaa & aca & yes\\
\hline
\end{tabular}
\end{center}
\caption{Amino Acid Coding}
\label{table:aacoding}
\end{table}

The variants that fall within coding regions are in chromosomes 1, 2 and 16. 
Here we create a \Robject{GRanges} of coding regions by transcripts and 
retain only the chromosomes of interest for the \Robject{subject}. Alternatively 
we could have used the full \Robject{TranscriptDb}.

<<aacoding>>=
library(BSgenome.Hsapiens.UCSC.hg18)
cdsByTx <- cdsBy(txdb)
grl <- keepSeqlevels(cdsByTx, c("chr1", "chr2", "chr16"))

aaCoding <- predictCoding(variants, grl, seqSource=Hsapiens,
    varAllele="varAllele")
head(aaCoding)
@

Our result is a \Robject{DataFrame} containing only the variants that
fell within a coding region. Columns include queryHits, 
txID, refSeq, varSeq, refAA, varAA, Consequence and any
metadata columns that were present in the \Robject{subject}. 

The result has one row for each transcript matched by a variant. The
queryHits column is the map back to the variants in the original \Robject{query}.
If a variant matches multiple transcripts,  multiple rows are returned
for that variant. For example, the variant in the sixth row of the 
\Robject{variants} object fell within a coding region and matched four transcripts. 
The first four rows of the aaCoding result are the data for this variant.

The Consequence column indicates `synonymous' or `nonsynonymous' for 
variants for which the codons could be translated. If translation was not 
possible the Consequence was considered a `frameshift'. Variants for which no 
amino acid codes were computed have a missing in value in the varAA column. 
<<aacodingResultOneVariant>>= 
aaCoding[width(aaCoding$varAA) == 0,] 
@


\section{Filtering Variants}

Identifying subsets of variants that meet a specific criteria can be
accomplished using the filter functions in the \Rpackage{VariantAnnotaion} package.
Filters are first created with the appropriate reference to construct the 
filter, either a dbSNP package or \Robject{TranscriptDb} object. 

<<createFilters>>=
library("SNPlocs.Hsapiens.dbSNP.20090506")
# variants present in dbSNP 
snpFilt <- dbSNPFilter("SNPlocs.Hsapiens.dbSNP.20090506")
snpFilt

# variants present in coding regions 
regionFilt <- regionFilter(txdb, region="coding")
regionFilt
@

When applying a filter to the data, the optional argument \Rcode{subset}
can be specified. If \Rcode{subset=TRUE} (the default), a \Robject{GRanges} 
object of subset data is returned. The filter name and number of 
records filtered are included in the object metadata. When \Rcode{subset=FALSE}
a \Robject{VAFilterResult} object is returned which contains a logical
vector indicating which records passed the filter.

<<filtering>>=
## return a subset of records passing the filter
snpResult <- snpFilt(variants)
snpResult 
metadata(snpResult)

# return a VAFilterResult object
snpFilt(variants, subset=FALSE)


# return a subset of data passing both filters
combofilt <- compose(snpFilt, regionFilt)
combofilt(variants)
@


\section{Variant Call Format (VCF) files}

The \Rcode{readVcf} function can be used to read VCF files into a 
\Rcode{SummarizedExperiment} object. Here we read in a 1000 Genomes 
pilot study data that contains the variant calls
made on the ~700 individuals which had exon targeted sequencing. 

If \Rcode{raw} = TRUE, the ranges and alleles in the
\Rcode{SummarizedExperiment} are returned exactly as they
appear in the VCF file. If the file has a tabix index, we
can read in select ranges by specifying a \Rcode{GRanges}
for the \Rcode{param} argument. 

<<readVCF_raw, eval=FALSE>>=

## create a TabixFile instance 
fl <- "pathToFile/CEU.exon.2010_03.sites.vcf.gz"
tab <- TabixFile(fl)
scanHeaderTabix(fl)

## select ranges  
gr <- GRanges(seqnames="21",
              ranges=IRanges(start=0, end=100000))


vcf_raw <- readVcf(tab, param=gr, raw=TRUE)
values(rowData(vcf_raw))[["ref"]]
values(rowData(vcf_raw))[["alt"]]
@ 

The VCF standard is to include the nucleotide 
immediately preceding an indel in the reference sequence. 
The start location is one less than the true position of the variation.
When \Rcode{raw} = FALSE, additional ranges are supplied
that reflect the \Rcode{Bioconductor} standards for
representing ranges. Additionally, the alleles are modified to retain only 
the basepairs involved in the variation. These modifications
are made to provide compatibility with existing methods. 
The modified ranges and alleles are in a \Rcode{DataFrame} in 
the `alt' field of the metadata. 

<<readVCF, eval=FALSE>>=
vcf <- readVcf(tab, param=gr, raw=FALSE)
values(rowData(vcf))[["ref"]]
values(rowData(vcf))[["alt"]]
@

\section{References}
Wang K, Li M, Hakonarson H, (2010), ANNOVAR: functional annotation of genetic 
variants from high-throughput sequencing data. Nucleic Acids Research, Vol 38,
No. 16, e164.\\

\noindent McLaren W, Pritchard B, RiosD, et. al., (2010), Deriving the consequences of
genomic variants with the Ensembl API and SNP Effect Predictor. Bioinformatics,
Vol. 26, No. 16, 2069-2070.

\section{Session Information}
<<sessionInfo>>=
sessionInfo()
@

\end{document}
