%\VignetteIndexEntry{Introduction to VariantAnnotation}
%\VignetteDepends{GenomicRanges, Rsamtools, Biostrings, AnnotationDbi, BSgenome}
%\VignetteKeywords{variants, sequence, sequencing, alignments}
%\VignettePackage{VariantAnnotation}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\VariantAnnotation}{\Rpackage{VariantAnnotation}}

\title{Introduction to \VariantAnnotation}
\author{Valerie Obenchain, Michael Lawrence}
\date{\today}

\begin{document} 

\maketitle

<<options, echo=FALSE>>=
options(width=72)
@

\section{Introduction}
In this vignette we demonstrate a general workflow for annotating and
filtering genetic variants using the \VariantAnnotation  package. As sample
data we use a Variant Call Format (VCF) file which is parsed into a
\Rfunction{VCF} object. We determine if the variants fall in a coding, UTR, 
intron or intergenic region and compute the amino acid coding changes for the 
non-synonymous variants. By querying the SIFT and PolyPhen database packages 
we obtain predictions the impact the amino acid coding changes in these 
non-synonymous variants may have on protein function. Filtering functions are 
available to subset variants on physical location in the gene or membership in 
dbSNP. 

\section{Variant Call Format (VCF) files}
Our sample data are a subset of 1000 variants and 50 samples from chromosome 22
downloaded from the 1000 Genomes web site,
\url{ftp://ftp-trace.ncbi.nih.gov/1000genomes/ftp/release/20110521/}.

<<readVcf>>=
library(VariantAnnotation)
vcffile <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
vcf <- readVcf(vcffile, "hg19")
@

If no ranges are specified in the \Robject{param} argument the full 
file is read in. A subset of data can be read in by specifying ranges, info and
or geno fields in a \Robject{ScanVcfParam} object. When ranges are included the 
file must have an accompanying Tabix index. See ?\Rcode{indexTabix} for 
help with creating an index file.

<<readVCF_subset, eval=FALSE>>=
## subset on ranges only
rngs <- GRanges(seqnames="22", ranges=IRanges(start=51151293, end=51152761))
param <- ScanVcfParam(which=rngs)
idx <- indexTabix(vcffile, "vcf")
tab <- TabixFile(vcffile, idx)
vcf_sub1 <- readVcf(tab, "hg19", param)

## subset on ranges, geno and info fields
param <- ScanVcfParam(geno="GT", info="LDAF", which=rngs)
vcf_sub2 <- readVcf(tab, "hg19", param) 
@

The data are parsed into a \Robject{VCF} object. The header is stored as a 
\Robject{SimpleList} in the \Rcode{exptData} slot and can be viewed by querying 
elements of the list.

<<readVCF_show>>=
vcf
exptData(vcf)[["HEADER"]]
exptData(vcf)[["HEADER"]][["META"]]
@

The CHROM, POS, and ID fields of the VCF file are parsed 
into a \Robject{GRanges} object in the \Rcode{rowData} slot. 

<<readVCF_rowData>>=
head(exptData(vcf)[["HEADER"]][["INFO"]], 3)
head(rowData(vcf), 3)
@

Individual fields of REF, ALT, QUAL, FILTER and INFO can be viewed individually 
with the \Rcode{rowData} using the \Rcode{ref}, \Rcode{alt}, \Rcode{qual},
\Rcode{filt} and \Rcode{info} accessors. All fixed fields can be viewed together
with the \Rcode{fixed} accessor.

<<fixedAccessors>>=
head(ref(vcf))
head(filt(vcf))

head(fixed(vcf), 3)
@


The genotype data described in the \Rcode{FORMAT} fields is parsed into 
matrices or arrays and can be accessed with the \Rcode{geno} accessor.
<<readVCF_geno>>=
exptData(vcf)[["HEADER"]][["FORMAT"]]
geno(vcf)
geno(vcf)$GT[1:6,1:5]
@

\subsection{SNPs}

When working with snp data, a snp matrix-type of object may be useful. The
\Rfunction{MatrixToSnpMatrix} function converts the genotype calls in
\Rcode{geno} to a \Robject{SnpMatrix}. The return value is a named list 
where "genotypes" is a \Robject{SnpMatrix} and "map" is a \Robject{DataFrame}
with snp names and alleles at the loci. The \Rcode{setNA} column indicates
which variants were set to NA due to the criteria specified at 
?\Rfunction{MatrixToSnpMatrix}.

<<snpMatrix>>=
## Genotypes have been parsed into the "GT" matrix
calls <- geno(vcf)$GT
a0 <- values(ref(vcf))[["REF"]]
a1 <- values(alt(vcf))[["ALT"]] 

MatrixToSnpMatrix(calls, a0, a1)
@

\section{Location of variants with respect to gene function}
The \Rfunction{locateVariants} function matches the ranges in a \Robject{GRanges}
with the coding, intron and UTR regions in a \Robject{TranscriptDb}. Metadata 
columns may be present in the \Robject{GRanges} but they are ignored.

As input to this function we use the \Robject{GRanges} from the \Rcode{rowData} 
slot in the \Robject{VCF} object. \Rcode{seqlevels} in the \Robject{GRanges} 
must be adjusted if they do not match those in the \Robject{TranscriptDb}.

<<location>>=
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb19 <- TxDb.Hsapiens.UCSC.hg19.knownGene 

## adjust seqlevels to match the txdb19
rd <- rowData(vcf)
seqlevels(rd) <- paste("chr", seqlevels(rd), sep="")
@

The return object is a \Robject{DataFrame} with at least one row for each 
variant. There are multiple rows for variants that match more than one
transcript. The queryHits column maps back to the variant in the original 
query. Location categories of `coding', `5'UTR', `3'UTR', `intron' and 
`intergenic' are assigned based on the criteria in Table \ref{table:location}. 
Intergenic variants have two gene ID's, representing the genes preceding and 
following the variant. 

\begin{verbatim}
> loc <- locateVariants(rd, txdb19)
> loc[515:605,]
DataFrame with 91 rows and 4 columns
    queryHits      txID                    geneID   Location
    <integer> <integer> <CompressedCharacterList>   <factor>
1         249     73653                     85358      3'UTR
2         250     73651                     85358     coding
3         250     73653                     85358     coding
4         251     73651                     85358     coding
5         251     73653                     85358     coding
6         252        NA               85358,85358 intergenic
7         253        NA               85358,85358 intergenic
8         254        NA               85358,85358 intergenic
9         255        NA               85358,85358 intergenic
...       ...       ...                       ...        ...
83        329     73654                               intron
84        330     73654                               intron
85        331     73654                               intron
86        332     73654                               intron
87        333        NA                  85358,49 intergenic
88        334        NA                  85358,49 intergenic
89        335        NA                  85358,49 intergenic
90        336     73655                        49      5'UTR
91        336     73656                        49      5'UTR
\end{verbatim}


\begin{table}[ht]
\begin{center}
\begin{tabular}{l|l}
\hline
Region & Details \\
\hline
coding &  variant falls \emph{within} a coding region \\
5'UTR &  variant falls \emph{within} a 5' untranslated region \\
3'UTR &  variant falls \emph{within} a 3' untranslated region \\
intron &  variant falls \emph{within} a transcript but not \emph{within} a 
coding region \\
intergenic & variant does not fall \emph{within} a transcript but does have
a nearest gene match\\
transcript\_region & variant falls \emph{within} a transcript but does not 
fall \emph{within} a specified region\\
NA & variant does not fall \emph{within} a transcript and has no
nearest gene match \\
NA & variant is on a chromosome present in \Robject{query} but not in the 
\Robject{subject}\\
\hline
\end{tabular}
\end{center}
\caption{Location of variants with respect to genes}
\label{table:location}
\end{table}

Here we have a summary of Location for all variant-transcript matches.
\begin{verbatim}
> table(loc$Location)

     3'UTR      5'UTR     coding intergenic     intron 
       215         32        168        211       3092 
\end{verbatim}

\section{Amino acid coding changes}

\Rfunction{predictCoding} provides amino acid coding changes for non-synonymous 
variants. This function identifies overlaps between the variants in 
\Robject{query} and the coding regions of a \Robject{TranscriptDb} object. 
Sequences for the reference codons are retrieved from either a \Robject{BSgenome} 
or fasta file. Codon sequences for the variants are constructed by substituting, 
inserting or deleting the values in the \Robject{varAllele} column into the 
reference sequence. Amino acid codes are computed for the resulting variant codon 
sequence when the length is a multiple of 3. Examples of various coding 
situations are shown in Table \ref{table:aacoding}. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{l|l|l|l|l|c}
\hline
Type & refAllele & varAllele & refSeq & varSeq & translation possible \\
\hline
substitution & G & T & aag & aaT & yes\\
substitution & G & TG & tga & tTGa & no\\
substitution & G & TGCG & gtc & TGCGtc & yes\\
insertion & `' & G & cgg & Gcgg & no\\
insertion & `' & TTG & gaa & gaTTGa & yes\\
deletion & A & `' & atc & tc & no\\
deletion & GGCCTA & `' & acggcctaa & aca & yes\\
\hline
\end{tabular}
\end{center}
\caption{Amino acid coding changes}
\label{table:aacoding}
\end{table}

Either a \Robject{TranscriptDb} or a \Robject{GRangesList} can be provided as 
the \Rcode{subject}. Because this function is concerned with coding regions 
only if a \Robject{GRangesList} is supplied it is assumed the outer list 
elements define coding regions and the individual elements fall within that coding 
region. When a \Robject{TranscriptDb} is supplied the approprate 
\Robject{GRangesList} is created by calling the \Rfunction{cdsBy} function
behind the scenes.

In keeping with our VCF example we again use the \Robject{GRanges} from
the \Rcode{rowData} slot as our \Robject{query} input. The one additional
pieces of information \Rfunction{predictCoding} requires is the variant
(or alternate) allele. The ALT column in the \Rcode{GRanges} is compressed
as each variant may have >1 alternate allele. We create a flattened 
\Rcode{GRanges} such that each row represents one variant-alternate allele 
pair and the ALT values are a DNAStringSet as required by
\Rfunction{predictCoding}.

<<flatten>>=
## expand the ALT column
ALT <- alt(vcf)
flat <- rep(ALT, elementLengths(values(ALT)[["ALT"]]))
seqlevels(flat) <- paste("chr", seqlevels(flat), sep="")
values(flat) <- DataFrame(ALT=unlist(values(ALT)[["ALT"]]))
@

We use a \Robject{BSgenome} as our sequence source but could have also used
an appropriate fasta file.

<<aacoding>>=
library(BSgenome.Hsapiens.UCSC.hg19)
aacoding <- predictCoding(
                query=flat, 
                subject=txdb19, 
                seqSource=Hsapiens, 
                varAllele="ALT")
@

The result is a \Robject{DataFrame} with one row for each variant-transcript 
match. Unlike \Rfunction{locateVariants}, this function only returns results 
for the variants that fall in a coding region. Columns are queryHits, txID, 
refSeq, varSeq, refAA, varAA, Consequence and any metadata columns that were 
present in the \Robject{subject}. The queryHits column is the map back to the 
variants in the original \Robject{query}. If translation was possible, the 
Consequence value will be `synonymous' or `nonsynonymous'. Where translation 
was not possible, Consequence will be `frameshift' and the varAA value will be
missing. 

<<aacoding_notranslation>>= 
head(aacoding, 4)

## Consequence is 'frameshift' where translation is not possible
head(aacoding[width(aacoding$varAA) == 0,], 4)
@

\section{Filtering}

Often it is useful to identify subsets of variants that meet a specific 
criteria. There are currently two built-in filters available in
\Rpackage{VariantAnnotation}. The \Rfunction{dbSNPfilter} checks for membership 
in dbSNP and \Rfunction{regionFilter} filters variants based on the locations 
identified with\Rfunction{locateVariants}. Filters are created with the 
appropriate reference object such as a \Robject{SNPlocs} or 
\Robject{TranscriptDb} object. 

<<createFilters>>=
## create filter to identify variants present in dbSNP 
library("SNPlocs.Hsapiens.dbSNP.20110815")
snpFilt <- dbSNPFilter("SNPlocs.Hsapiens.dbSNP.20110815")
vaFilter(snpFilt)

## create filter to identify variants present in introns 
regionFilt <- regionFilter(txdb19, region="intron")
vaFilter(regionFilt)
@

When filtering data with \Rfunction{dbSNPFilter} or \Rfunction{regionsFilt} two 
options are available for the return object. If the argument \Rcode{subset=TRUE}
(default) a \Robject{GRanges} is returned that contains only the records that
passed the filter. If \Rcode{subset=FALSE}, the result is a 
\Robject{VAFilterResult} object. This object contains a logical vector 
indicating which records passed the filter and some statistics on the number of 
records removed and what filter was applied. 

First we return the subset of variants that are in dbSNP. Again, the variant 
seqlevels need to be adjusted to match the seqlevels of the annotation.
<<filtering>>=
## return the subset of records that passed the filter
rd <- rowData(vcf)
seqlevels(rd) <- paste("ch", seqlevels(rd), sep="")
dbsnp <- snpFilt(rd)
summary(dbsnp) 
metadata(dbsnp)

## return a VAFilterResult object
snpFilt(rd, subset=FALSE)
@

Next we identify the variants that fall in an intron region.
\begin{verbatim}
> rd <- rowData(vcf)
> seqlevels(rd) <- paste("chr", seqlevels(rd), sep="")
> intron <- regionFilt(rd)
> summary(intron)
 Length   Class    Mode 
    712 GRanges      S4 
\end{verbatim}

\section{SIFT and PolyPhen Databases}

From \Rfunction{predictCoding} we identified the amino acid coding changes for 
the non-synonymous variants. For this subset of variants we retrieve predictions 
of how damaging these coding changes may be. SIFT (Sorting Intolerant From 
Tolerant) and PolyPhen (Polymorphism Phenotyping) are methods that predict the 
impact of amino acid substitution on a human protein. The SIFT method uses 
sequence homology and the physical properties of amino acids to make predictions 
about protein function. PolyPhen uses sequence-based features and structural 
information characterizing the substitution to make predictions about the 
structure and function of the protein. 

Collated predictions for specific dbSNP builds are available as downloads from 
the SIFT and PolyPhen web sites. These results have been packaged into
\Rpackage{SIFT.Hsapiens.dbSNP132.db} and \Rpackage{PolyPhen.Hapiens.dbSNP131.db} 
and are designed to be searched by rsid.

We identify the non-synonymous variants and obtain the rsids.
<<nonsynonymous>>=
nonsyn <- with(aacoding, unique(queryHits[Consequence == "nonsynonymous"]))
nonsyn

nms <- names(rd[nonsyn])
rsids <- nms[grep("rs", nms, fixed=TRUE)]
rsids
@

Detailed descriptions of the database columns can be found with
\Rcode{?SIFTDbColumns} and \Rcode{?PolyPhenDbColumns}. Variants in these
databases often contain more than one row per variant. The variant may have
been reported by multiple sources and therefore the source will differ as well
as some of the other variables. 

<<sift>>=
library(SIFT.Hsapiens.dbSNP132)

## rsids in the package 
head(keys(SIFT.Hsapiens.dbSNP132))

## list available columns
cols(SIFT.Hsapiens.dbSNP132)

## select a subset of columns
## a warning is thrown when a key is not found in the database
subst <- c("RSID", "PREDICTION", "SCORE", "AACHANGE", "PROTEINID")
sift <- select(SIFT.Hsapiens.dbSNP132, keys=rsids, cols=subst)
head(sift)
@

Next we query the PolyPhen database for information on these variants.
The PolyPhen dataset is for dbSNP build 131 and we see it does not include
all of the variants. PolyPhen provides predictions using two different
training datasets and has considerable information about 3D protein structure. 
See \Rcode{?PolyPhenDbColumns} or the PolyPhen web site listed in the
references for more details.
<<polyphen>>=
library(PolyPhen.Hsapiens.dbSNP131)
pp <- select(PolyPhen.Hsapiens.dbSNP131, keys=rsids, 
         cols=c("TRAININGSET", "PREDICTION", "PPH2PROB", "AA1", "AA2"))
head(pp)
@

\section{References}
Wang K, Li M, Hakonarson H, (2010), ANNOVAR: functional annotation of genetic 
variants from high-throughput sequencing data. Nucleic Acids Research, Vol 38,
No. 16, e164.\\

\noindent McLaren W, Pritchard B, RiosD, et. al., (2010), Deriving the consequences of
genomic variants with the Ensembl API and SNP Effect Predictor. Bioinformatics,
Vol. 26, No. 16, 2069-2070.\\

\noindent SIFT home page :
\url{http://sift.bii.a-star.edu.sg/}\\

\noindent PolyPhen home page :
\url{http://genetics.bwh.harvard.edu/pph2/}

\section{Session Information}
<<sessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
