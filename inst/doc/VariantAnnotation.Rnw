%\VignetteIndexEntry{Introduction to VariantAnnotation}
%\VignetteDepends{GenomicRanges, Rsamtools, Biostrings, AnnotationDbi, BSgenome}
%\VignetteKeywords{variants, sequence, sequencing, alignments}
%\VignettePackage{VariantAnnotation}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\VariantAnnotation}{\Rpackage{VariantAnnotation}}

\title{Introduction to \VariantAnnotation}
\author{Valerie Obenchain, Michael Lawrence}
\date{\today}

\begin{document} 

\maketitle

<<options, echo=FALSE>>=
options(width=72)
@

\section{Introduction}
In this vignette we demonstrate a general workflow for annotating and
filtering genetic variants using the \VariantAnnotation  package. The sample
data is in a Variant Call Format (VCF) file which is read in and parsed it into a
\Rfunction{SummarizedExperiment} object. We determine if the variants
fall in a coding, UTR, intron or intergenic region and compute the amino
acid coding changes for the nonsynonymous variants. By querying the SIFT and 
PolyPhen database packages we obtain predictions for the impact the amino acid 
coding changes may have on protein function (SIFT) or on function and structure
(PolyPhen). Filtering functions are available for subsetting the variants on 
physical location in the gene or membership in dbSNP. 

\section{Variant Call Format (VCF) files}
Our sample data are a subset of 1000 variants and 50 samples from chromosome 22
downloaded from the 1000 Genomes web site,
\url{ftp://ftp-trace.ncbi.nih.gov/1000genomes/ftp/release/20110521/}.
If no \Robject{param} argument is supplied to \Rfunction{readVcf} the entire
file is read in.

<<readVCF>>=
library(VariantAnnotation)
vcffile <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
vcf <- readVcf(vcffile, "hg19")
@

To read in a subset of data we specify a \Rcode{GRanges} of the desired ranges 
as the \Rcode{param}. To access a subset of ranges the VCF file must have an 
accompying Tabix index file. See ?\Rcode{indexTabix} for help creating an index 
file.

<<readVCF_subset, eval=FALSE>>=
rngs <- GRanges(seqnames="16", ranges=IRanges(start=0, end=1e07))
vcf_16 <- readVcf(vcffile, "hg19", param=rngs)
@

The data are parsed into a \Rcode{SummarizedExperiment} according to the header 
information in the VCF file. The header is stored as a \Rcode{SimpleList} in the 
\Rcode{exptData} slot and can be viewed by querying the elements
of the list.

<<readVCF_show>>=
vcf
exptData(vcf)[["HEADER"]]
exptData(vcf)[["HEADER"]][["META"]]
@

The eight required fields of the VCF file are parsed into a \Rcode{GRanges}
object in the \Rcode{rowData} slot. The \Rcode{ALT} alleles are provided as 
a \Rcode{DNAStringSet} inside a \Rcode{DataFrameList}. 

<<readVCF_rowData>>=
head(exptData(vcf)[["HEADER"]][["INFO"]], 3)
rowData(vcf)[1:3,1:4]
@

The genotype data described in the \Rcode{FORMAT} fields are parsed into 
matrices in the \Rcode{assays} slot.
<<readVCF_assays>>=
exptData(vcf)[["HEADER"]][["FORMAT"]]
assays(vcf)
assays(vcf)$GT[1:6,1:5]
@

\section{Location of variants with respect to gene function}
The \Rcode{locateVariants} function matches the ranges in a \Robject{GRanges}
query with the coding, intron and UTR regions in a \Robject{TranscriptDb}
subject. Metadata columns may be present in the \Robject{GRanges} but they are
ignored.

As input to this function we use the \Robject{GRanges} object from the 
\Rcode{rowData} slot in our \Robject{SummarizedExperiment}. Variants 
coming from other sources will need to be put into a \Robject{GRanges} object.
\Rcode{seqlevels} in the \Robject{GRanges} must be adjusted if they do not
match those in the \Robject{TranscriptDb}.

<<location>>=
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb19 <- TxDb.Hsapiens.UCSC.hg19.knownGene 

## adjust seqlevels to match the txdb19
rd <- rowData(vcf)
seqlevels(rd) <- paste("chr", seqlevels(rd), sep="")

loc <- locateVariants(rd, txdb19)
head(loc)
@

The return object is a \Robject{DataFrame} with one row for each 
variant-transcript match. The queryHits column maps back to the variant
in the original query. Location categories of `coding', `UTR5', `UTR3', `intron' 
and `intergenic' are assigned based on the criteria in Table 
\ref{table:location}. Intergenic variants have two gene ID's, representing the 
genes preceding and following the variant. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{l|l}
\hline
Region & Details \\
\hline
coding &  variant falls \emph{within} a coding region \\
UTR5 &  variant falls \emph{within} a 5' untranslated region \\
UTR3 &  variant falls \emph{within} a 3' untranslated region \\
intron &  variant falls \emph{within} a transcript but not \emph{within} a 
coding region \\
intergenic & variant does not fall \emph{within} a transcript but does have
a nearest gene match\\
transcript\_region & variant falls \emph{within} a transcript but does not 
fall \emph{within} a specified region\\
NA & variant does not fall \emph{within} a transcript and has no
nearest gene match \\
NA & variant is on a chromosome present in \Robject{query} but not in the 
\Robject{subject}\\
\hline
\end{tabular}
\end{center}
\caption{Location of variants with respect to genes}
\label{table:location}
\end{table}

<<explore_locateVariants>>=
table(loc$Location)
@

\section{Amino acid coding changes}

\Rfunction{predictCoding} provides amino acid coding changes for non-synonymous 
variants. This function identifies overlaps between the variants in 
\Robject{query} and the coding regions of a \Robject{TranscriptDb} object. 
Sequences for the reference codons are retrieved from either a \Robject{BSgenome} 
or fasta file. Codon sequences for the variants are constructed by substituting, 
inserting or deleting the values in the \Robject{varAllele} column into the 
reference sequence. Amino acid codes are computed for the resulting variant codon 
sequence when the length is a multiple of 3. Examples of various coding 
situations are shown in Table \ref{table:aacoding}. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{c|c|c|c|c|c}
\hline
Type & refAllele & varAllele & refSeq & varSeq & AA coding of varSeq  \\
\hline
substitution & G & T & aag & aaT & yes\\
substitution & G & TG & tga & tTGa & no\\
substitution & G & TGCG & gtc & TGCGtc & yes\\
insertion & `' & G & cgg & Gcgg & no\\
insertion & `' & TTG & gaa & gaTTGa & yes\\
deletion & A & `' & atc & tc & no\\
deletion & GGCCTA & `' & acggcctaa & aca & yes\\
\hline
\end{tabular}
\end{center}
\caption{Amino acid coding changes}
\label{table:aacoding}
\end{table}

Either a \Robject{TranscriptDb} or a \Robject{GRangesList} can be provided as 
the \Rcode{subject}. Because this function is concerned with coding regions 
only if a \Robject{GRangesList} is supplied it is assumed the outer list 
elements define coding regions and the individual elements fall within that coding 
region. When a \Robject{TranscriptDb} is supplied the approprate 
\Robject{GRangesList} is created by calling the \Rfunction{cdsBy} function
behind the scenes.

In keeping with our VCF example we again use the \Robject{GRanges} from
the \Rcode{rowData} slot as our \Robject{query} input. The one additional
pieces of information \Rfunction{predictCoding} requires is the variant
(or alternate) allele. The ALT column in the \Rcode{GRanges} is compressed
because each variant may have >1 alternate allele. We flatten the 
\Rcode{GRanges} to create one row for each alternate variant-alternate allele 
pair.

<<flatten>>=
rdflat <- rep(rd, elementLengths(values(rd)[["ALT"]]))
values(rdflat) <- unlist(values(rd)[["ALT"]])
@

We use a \Robject{BSgenome} as our sequence source but could have also used
an appropriate fasta file.

<<aacoding>>=
library(BSgenome.Hsapiens.UCSC.hg19)
aacoding <- predictCoding(
              query=rdflat, 
              subject=txdb19, 
              seqSource=Hsapiens, 
              varAllele="ALT")
head(aacoding)
@

The result is a \Robject{DataFrame} with one row for each variant-transcript
match. Only variants that fell in coding regions are included. Columns include 
queryHits, txID, refSeq, varSeq, refAA, varAA, Consequence and any metadata 
columns that were present in the \Robject{subject}. 

The queryHits column is the map back to the variants in the original 
\Robject{query}. The Consequence column indicates `synonymous' or 
`nonsynonymous' for variants for which the codons could be translated. 
If translation was not possible the Consequence was considered a 
`frameshift'. Variants for which no amino acid codes were computed have 
a missing in value in the varAA column. 

<<aacodingResultOneVariant>>= 
head(aacoding[width(aacoding$varAA) == 0,], 3)
@

\section{Filtering}

Often it is useful to identify subsets of variants that meet a specific 
criteria. There are currently two built-in filters available in
\Rpackage{VariantAnnotation}. The \Rfunction{dbSNPfilter} checks for membership 
in dbSNP and \Rfunction{regionFilter} filters variants based on the locations 
identified with\Rfunction{locateVariants}. Filters are created with the 
appropriate reference object such as a \Robject{SNPlocs} or 
\Robject{TranscriptDb} object. 

<<createFilters>>=
## create filter to identify variants present in dbSNP 
library("SNPlocs.Hsapiens.dbSNP.20110815")
snpFilt <- dbSNPFilter("SNPlocs.Hsapiens.dbSNP.20110815")

## create filter to identify variants present in introns 
regionFilt <- regionFilter(txdb19, region="intron")
regionFilt
@

When filtering data with \Rfunction{dbSNPFilter} or \Rfunction{regionsFilt} two 
options are available for the return object. If the argument \Rcode{subset=TRUE}
(default) a \Robject{GRanges} is returned that contains only the records that
passed the filter. If \Rcode{subset=FALSE}, the result is a 
\Robject{VAFilterResult} object. This object contains a logical vector 
indicating which records passed the filter and some statistics on the number of 
records removed and what filter was applied. 

First we return the subset of variants that are in dbSNP. Again, the variant 
seqlevels need to be adjusted to match the seqlevels of the annotation.
<<filtering>>=
## return the subset of records that passed the filter
rd <- rowData(vcf)
seqlevels(rd) <- paste("ch", seqlevels(rd), sep="")
dbsnp <- snpFilt(rd)
summary(dbsnp) 
metadata(dbsnp)

## return a VAFilterResult object
snpFilt(rd, subset=FALSE)
@

Next we identify the variants that fall in an intron region.
\begin{verbatim}
> rd <- rowData(vcf)
> seqlevels(rd) <- paste("chr", seqlevels(rd), sep="")
> intron <- regionFilt(rd)
> summary(intron)
 Length   Class    Mode 
    712 GRanges      S4 
\end{verbatim}

\section{SIFT and PolyPhen Databases}

From \Rfunction{predictCoding} we identified the amino acid coding 
changes for the non-synonymous variants. For this subset of variants we
now retrieve predictions of how dammaging these coding changes may be. SIFT 
(Sorting Intolerant From Tolerant) and PolyPhen (Polymorphism Phenotyping)
are methods that predict the impact of amino acid substitution on a human 
protein. The SIFT method uses sequence homology and the physical properties of 
amino acids to make predictions about protein function. PolyPhen uses sequence-
based features and structural information characterizing the substitution to 
make predictions about the structure and function of the protein. 

Collated predictions for specific dbSNP builds are available as downloads from 
the SIFT and PolyPhen web sites. These results have been packaged in the 
\Rcode{Bioconductor} packages \Rpackage{SIFT.Hsapiens.dbSNP132.db} and 
\Rpackage{PolyPhen.Hapiens.dbSNP131.db}. The packages are designed to be 
searched by rsid so we get that information first.

<<nonsynonymous>>=
nonsyn <- unique(aacoding$queryHits[aacoding$Consequence == "nonsynonymous"])
nonsyn
@

We subset the original query on the non-synonymous variants and obtain the 
rsids.
<<rsids>>=
nms <- names(rd[nonsyn])
## remove non-rsids 
rsids <- nms[grep("rs", nms, fixed=TRUE)]
@

%% Maybe a FIXME?
Detailed descriptions of the database columns can be found with
\Rcode{?SIFTDbColumns} and \Rcode{?PolyPhenDbColumns}. Because of the large 
number of columns the results will often vary in just one column.
When viewing a subset of the columns they may look identical. 
<<sift>>=
library(SIFT.Hsapiens.dbSNP132)

## rsids in the package 
head(keys(SIFT.Hsapiens.dbSNP132))

## list available columns
cols(SIFT.Hsapiens.dbSNP132)

#subst <- c("RSID", "PREDICTION", "SCORE", "AACHANGE", "PROTEINID")
#sift <- select(SIFT.Hsapiens.dbSNP132, keys=rsids, cols=subst)
#head(sift)
@

Now we take a look at the PolyPhen predictions for the same variants
and a subset of columns
<<polyphen>>=
library(PolyPhen.Hsapiens.dbSNP131)
#ppp <- select(PolyPhen.Hsapiens.dbSNP131, keys=rsids, 
#         cols=c("TRAININGSET", "PREDICTION", "PPH2PROB", "PPH2FPR", "PPH2FDR"))
#head(pp)
@

\section{References}
Wang K, Li M, Hakonarson H, (2010), ANNOVAR: functional annotation of genetic 
variants from high-throughput sequencing data. Nucleic Acids Research, Vol 38,
No. 16, e164.\\

\noindent McLaren W, Pritchard B, RiosD, et. al., (2010), Deriving the consequences of
genomic variants with the Ensembl API and SNP Effect Predictor. Bioinformatics,
Vol. 26, No. 16, 2069-2070.
\noindent SIFT home page :
\url{http://sift.bii.a-star.edu.sg/}
\noindent PolyPhen home page :
\url{http://genetics.bwh.harvard.edu/pph2/}

\section{Session Information}
<<sessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
