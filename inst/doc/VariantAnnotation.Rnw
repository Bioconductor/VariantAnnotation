%\VignetteIndexEntry{Introduction to VariantAnnotation}
%\VignetteKeywords{variants, sequence, sequencing, alignments}
%\VignettePackage{VariantAnnotation}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\VariantAnnotation}{\Rpackage{VariantAnnotation}}

\title{Introduction to \VariantAnnotation}
\author{Valerie Obenchain, Michael Lawrence}
\date{\today}

\begin{document} 

\maketitle
\tableofcontents

<<options, echo=FALSE>>=
options(width=72)
@

\section{Introduction}
This vignette demonstrates a general workflow for annotating and filtering 
genetic variants using the \VariantAnnotation  package. Sample data are 
in VariantCall Format (VCF) and are a subset of 1000 variants and 50 samples 
from chromosome 22 taken from 1000 Genomes,
\url{ftp://ftp-trace.ncbi.nih.gov/1000genomes/ftp/release/20110521/}.
VCF is a text file format that contains meta-information lines, a header line 
with column names, data lines with information about a position in the genome, 
and optional genotype information on samples for each position. A full 
description of the VCF format can be found on the 1000 Genomes page,
\url{http://www.1000genomes.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-41}

In the following workflow we read in data from a VCF file and locate
the variants with respect to gene function. Amino acid coding changes
are computed for the non-synonymous variants. SIFT and PolyPhen databases are 
queried to provide predictions of how severly these amino acid coding changes 
affect protein function. At the end of the vignette we cover other
transformations of the VCF data such as the creation of a \Robject{SnpMatrix} or
a 'flattened' \Robject{GRanges} which is an expanded form of the VCF data.

\section{Reading Variant Call Format (VCF) files}

<<readVcf>>=
library(VariantAnnotation)
vcffile <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
vcf <- readVcf(vcffile, "hg19")
@

Data are parsed into a \Robject{VCF} object with \Rfunction{readVcf}. 

<<readVCF_show>>=
vcf
@

Header information from the VCF file is stored as a \Robject{SimpleList} in the 
\Rcode{exptData} slot and can be viewed by querying elements of the list.

<<readVCF_showheader>>=
exptData(vcf)[["HEADER"]]
exptData(vcf)[["HEADER"]][["META"]]
@

The CHROM, POS, and ID fields of the VCF file are used to create a 
\Robject{GRanges} object which is stored in the \Rcode{rowData} slot. 

<<readVCF_rowData>>=
head(rowData(vcf))
@

The REF, ALT, QUAL and FILTER fields can be accessed together with 
\Rcode{fixedFields} accessor or individually with \Rcode{ref}, \Rcode{alt}, 
\Rcode{qual} and \Rcode{filt} accessors. 

<<readVCF_fixed>>=
head(fixedFields(vcf), 3)
@

The \Robject{ALT} column is stored as a \Robject{DNAStringSetList} unless
the file is a structural VCF, in which case it is stored as a 
\Robject{CharacterList}. To take a closer look at \Robject{ALT} we extract 
it from the \Robject{GRanges} and determine the number of elements in the
list. In this case we have only 1 alternate allele value per variant.

<<readVCF_ALT>>=
alternate <- values(alt(vcf))[["ALT"]]
alternate

## number of ALT values per variant
unique(elementLengths(alternate))
head(unlist(alternate))
@

Data from the \Rcode{INFO} field can be accessed with the \Rcode{info} accessor
function. Detailed information for each of the \Rcode{INFO} fields can be
accessed with the \Rfunction{exptData} accessor. To view all of REF, ALT, QUAL, 
FILTER and INFO together use the \Rfunction{fixed} accessor. Note the difference 
between the \Rfunction{fixedFields} and \Rfunction{fixed} accessors. The first 
returns REF, ALT, QUAL and FILTER fields while the second also returns INFO. 
<<readVCF_info>>=
## header information related to the INFO fields
head(exptData(vcf)[["HEADER"]][["INFO"]], 3)

## just the INFO data
info(vcf)[1:3, 1:3]

## all fixed fields
fixed(vcf)[1:3, 1:7] 
@

The genotype data described in the \Rcode{FORMAT} field is parsed into 
matrices or arrays and can be accessed with \Rcode{geno}. These data
are not returned with the \Robject{GRanges} from the \Rcode{rowData}
slot because the data structures can be multidimentional.
<<readVCF_geno>>=
## header information related to the genotype fields
exptData(vcf)[["HEADER"]][["FORMAT"]]
geno(vcf)
geno(vcf)$GT[1:3,1:5]
geno(vcf)$DS[1:3,1:5]
@

\subsection{Reading subsets of data}
When working with large VCF files it may be more efficient to read in subsets 
of the data. Data can be subset by selecting genomic coordinates or by
selecting fields from the VCF file. 

\subsubsection{Genomic coordinates}
Subset by genomic coordinates by creating a \Robject{GRanges}, 
\Robject{RangedData} or \Robject{RangesList}. To read in a portion of
chromosome 22, we create a \Robject{GRanges} with the regions of interest.

<<subset_ranges>>=
rng <- GRanges(seqnames="22", ranges=IRanges(start=51151293, end=51152761))
@

When ranges are specified, the VCF file must have an accompanying Tabix index 
file; if one does not exist it must be created. See ?\Rcode{indexTabix} for 
help creating an index. 

Once the index exists we can create \Robject{TabixFile} instance. See 
?\Rcode{TabixFile}. This object creates a reference to the VCF and its index. 
Once opened, the reference remains open across calls to methods, avoiding costly 
index re-loading. An index file for our sample data is included in the package
so we now create the \Rcode{TabixFile}.

<<subset_TabixFile>>=
tab <- TabixFile(vcffile)
tab
@

Once the \Robject{TabixFile} is created \Rfunction{readVcf} is called with the 
\Robject{TabixFile} as the \Robject{file} argument and the ranges as the 
\Robject{param}. The resulting \Robject{VCF} object shows that 27 of the total 1000
variants overlaped with our defined ranges and were read in. 
<<subset_call>>= 
vcf_rng <- readVcf(tab, "hg19", param=rng)
vcf_rng
@

\subsubsection{VCF fields}
Data can also be subset on the \Rcode{INFO} and/or \Rcode{FORMAT} fields in the
VCF file. To discover what fields are available for subsetting we call
\Rfunction{ScanVcfHeader}. The return value is a list of length 3 with names
of 'Reference', 'Sample' and 'Header'. 

<<subset_scanVcfHeader>>=
hdr <- scanVcfHeader(vcffile)
hdr
hdr[[1]]$Header
@ 

INFO and FORMAT elements of 'Header' are \Robject{DataFrames} which contain a
description of the fields as well as the data type and number of values. All
possible elements can be listed by looking at the rownames.

<<subset_infoformat>>=
## all INFO fields
info_DF <- hdr[[1]]$Header$INFO
rownames(info_DF)
## all FORMAT fields
geno_DF <- hdr[[1]]$Header$FORMAT
rownames(geno_DF)
@

We are interested in "LDAF" in INFO which is 'allele frequency accounting 
for linkage disequlibrium', and "GT" in FORMAT which is 'genotype'. Full 
descriptions of the elements can be seen in the header INFO and FORMAT 
\Robject{DataFrames}.
<<subset_elements>>=
info_DF[rownames(info_DF) == "LDAF", ]
geno_DF[rownames(geno_DF) == "GT", ]
@

To subset on "LDAF" and "GT" we specify them as \Rcode{character} vectors 
in the \Rcode{info} and \Rcode{geno} arguments to \Rcode{ScanVcfParam}. This
creates a \Robject{ScanVcfParam} object which is used as the \Robject{param}
argument to \Rfunction{readVcf}. 

<<subset_ScanVcfParam>>=
svp <- ScanVcfParam(geno="GT", info="LDAF")
svp
@

Note that subsetting by the VCF fields does not affect the number of ranges read 
in ('dim' in show method). Instead the results of the filtering are reflected in 
the names of the elements listed in the the 'info' and 'geno' of the 
\Robject{VCF} object. 

<<subset_ScanVcfParam2>>=
vcf_flds <- readVcf(vcffile, "hg19", param=svp)
vcf_flds
@

In the previous section we saw that a Tabix index file must exist when data are
subset by genomic coordinates (i.e., ranges). This is not the case when 
subsetting on INFO and FORMAT elements. An index file is only needed when 
subsetting by ranges.

\subsubsection{Subset on both genomic coordinates and VCF fields}
To subset on both genomic coordinates and INFO and FORMAT fields the
\Robject{ScanVcfParam} object must contain both. Our previous 
\Robject{ScanVcfParam} did not have ranges associated with it so we create a 
new instance with the ranges and INFO and FORMAT fields. 

<<subset_ScanVcfParam_new>>=
svp_all <- ScanVcfParam(geno="GT", info="LDAF", which=rng) 
svp_all
@

Part of our subsetting here will be on genomic coordinates so again we need a 
Tabix index file. We will use the \Robject{TabixFile} we created previously.

<<subset_both>>=
readVcf(tab, "hg19", param=svp_all) 
@

\subsection{Adjusting chromosome names}
Several functions in this pacakge involve the comparision of ranges from a
VCF file and ranges in a \Robject{TranscripDb} object. For overlap
methods to work properly the chromosome names, or seqlevels, must be
compatible. 

For the VCF data we just read in the chromosome names are represented by number 
only, i.e. '22',
<<seqlevels_rd>>=
rowdat <- rowData(vcf)
seqlevels(rowdat)
@

but in the TxDb we will be comparing to they are preceeded by 'chr'.
<<seqlevels_TxDb>>=
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb19 <- TxDb.Hsapiens.UCSC.hg19.knownGene 
head(seqlevels(txdb19))
@

Chromosome names can be modified with the \Rfunction{renameSeqlevels}
function. Seqlevels are modified at the \Robject{GRanges} level in the
\Robject{rowData} slot of the \Robject{VCF} which means all future data 
extractions from this \Robject{VCF} will have the new seqlevels. 
If the data are read in from the file again, however, the seqlevels will 
need to be adjusted again. See ?\Rfunction{VCF} and ?\Rfunction{renameSeqlevels} 
for examples with \Robject{VCF} and \Robject{GRanges} objects.

<<seqlevels_rename>>=
## rename variant seqlevels in the VCF object
vcf <- renameSeqlevels(vcf, c("22"="chr22"))

## extract the rowData with modified seqlevels
rd <- rowData(vcf)
 
## confirm seqlevels are the same
intersect(seqlevels(rd), seqlevels(txdb19))
@

Our sample data contains ranges for chromosome 22 only so there is no need for 
further subsetting. However, if we had additional chromosomes we wanted to 
drop we can easily subset a \Robject{GRanges} or a \Robject{VCF} object using 
\Rfunction{keepSeqlevels}. As an example we extract transcripts for all 
chromosomes in TxDb.Hsapiens.UCSC.hg19.knownGene then keep only 'chr21' and 
'chr22'. See ?\Robject{VCF} and ?\Rfunction{keepSeqlevels} for details. 
\begin{verbatim}
## initially there are 93 chromosomes
> rngs <- transcripts(txdb19)
> length(seqlevels(rngs))
[1] 93
## keep only chr21 and chr22 
> rngs <- keepSeqlevels(rngs, c("chr21", "chr22"))
> seqlevels(rngs)
[1] "chr21" "chr22"
\end{verbatim}

\section{Variant location}
The \Rfunction{locateVariants} function matches ranges in a \Robject{GRanges}
object to the coding, intron and UTR regions in a \Robject{TranscriptDb}. 
Metadata columns may be present in the \Robject{GRanges} but they are ignored.
When a \Robject{VCF} is provided as the \Robject{query} the variant ranges come 
from the \Rcode{rowData} slot.

\begin{verbatim}
> loc <- locateVariants(rd, txdb19)
> loc[515:605,]
DataFrame with 91 rows and 5 columns
      queryID   location      txID                    geneID     cdsID
    <integer>   <factor> <integer> <CompressedCharacterList> <integer>
1         249      3'UTR     73653                     85358    226441
2         250     coding     73651                     85358    226416
3         250     coding     73653                     85358    226441
4         251     coding     73651                     85358    226416
5         251     coding     73653                     85358    226441
6         252 intergenic        NA                  85358,49        NA
7         253 intergenic        NA                  85358,49        NA
8         254 intergenic        NA                  85358,49        NA
9         255 intergenic        NA                  85358,49        NA
...       ...        ...       ...                       ...       ...
83        329     intron     73654                                  NA
84        330     intron     73654                                  NA
85        331     intron     73654                                  NA
86        332     intron     73654                                  NA
87        333 intergenic        NA                  85358,49        NA
88        334 intergenic        NA                  85358,49        NA
89        335 intergenic        NA                  85358,49        NA
90        336      5'UTR     73655                        49    226443
91        336      5'UTR     73656                        49    226443
\end{verbatim}

\Rfunction{locateVariants} returns a \Robject{DataFrame} with 5 columns. The
\Rcode{queryID} column maps back to the row number in the original 
\Robject{GRanges} of variants. Each row represents a variant-transcript overlap 
therfore multiple rows per variant are possible. Location categories of `coding', 
`5'UTR', `3'UTR', `intron' and `intergenic' are assigned based on the criteria 
in Table \ref{table:location}. Intergenic variants will have gene IDs for both
preceding and following genes.

\begin{table}[h!]
\begin{center}
\begin{tabular}{l|l}
\hline
Location & Details \\
\hline
coding &  variant falls \emph{within} a coding region \\
5'UTR &  variant falls \emph{within} a 5' untranslated region \\
3'UTR &  variant falls \emph{within} a 3' untranslated region \\
intron &  variant falls \emph{within} a transcript but not \emph{within} a 
coding region \\
intergenic & variant does not fall \emph{within} a transcript but does have
a nearest gene match\\
transcript\_region & variant falls \emph{within} a transcript but does not 
fall \emph{within} a specified region\\
NA & variant does not fall \emph{within} a transcript and has no
nearest gene match \\
NA & variant is on a chromosome present in \Robject{query} but not in the 
\Robject{subject}\\
\hline
\end{tabular}
\end{center}
\caption{Location of variants with respect to genes}
\label{table:location}
\end{table}

Each variant has the potential to match multiple transcripts and the output 
from \Rfunction{locateVariants} can be large. Further processing may
be necessary to better understand the data. A first step might be to summarize
'location' by gene while accounting for the variants that hit multiple 
transcripts in the same gene.

%% FIXME : modify example 
\begin{verbatim}
> single <- loc[elementLengths(loc$geneID) == 1, ]
> genes <- data.frame(queryID=single$queryID, geneID=unlist(single$geneID), 
+                     location=single$location)
> dups <- duplicated(genes)
> genesLst <- split(genes$location[!dups], genes$geneID[!dups]) 
> lapply(genesLst, table)
$`11158`

     3'UTR      5'UTR     coding intergenic     intron 
        18          3          7          0        178 

$`284942`

     3'UTR      5'UTR     coding intergenic     intron 
        18          3          7          0        362 

$`49`

     3'UTR      5'UTR     coding intergenic     intron 
         4          1         16          0         85 

$`85358`

     3'UTR      5'UTR     coding intergenic     intron 
         5          0         23          0        223 

\end{verbatim}


\section{Amino acid coding}

\Rfunction{predictCoding} computes amino acid coding changes for non-synonymous 
variants. This function identifies overlaps between the variants in 
\Robject{query} and the coding regions of a \Robject{TranscriptDb} object. 
Sequences for the reference codons are retrieved from either a \Robject{BSgenome} 
or fasta file. Codon sequences for the variants are constructed by substituting, 
inserting or deleting the values in the \Robject{varAllele} column into the 
reference sequence. Amino acid codes are computed for the resulting variant codon 
sequence when the length is a multiple of 3. Examples of various coding 
situations are shown in Table \ref{table:aacoding}. 

The \Robject{query} argument to \Rfunction{predictCoding} can be a 
\Robject{GRanges} or \Robject{VCF}. When a \Robject{GRanges} is supplied 
the \Rcode{varAllele} argument must be specified; when working with a
\Robject{VCF} the alternate alleles are taken from
\Robject{values(alt(<VCF>))[["ALT"]]} and therefore \Robject{varAllele} is not 
specified in the function call. \Robject{seqSource} can be a \Robject{BSgenome} 
as or an appropriate fasta file.

\begin{table}[h!]
\begin{center}
\begin{tabular}{l|l|l|l|l|c}
\hline
Type & refAllele & varAllele & refSeq & varSeq & translation possible \\
\hline
substitution & G & T & aag & aaT & yes\\
substitution & G & TG & tga & tTGa & no\\
substitution & G & TGCG & gtc & TGCGtc & yes\\
insertion & `' & G & cgg & Gcgg & no\\
insertion & `' & TTG & gaa & gaTTGa & yes\\
deletion & A & `' & atc & tc & no\\
deletion & GGCCTA & `' & acggcctaa & aca & yes\\
\hline
\end{tabular}
\end{center}
\caption{Amino acid coding changes}
\label{table:aacoding}
\end{table}


The return object from \Rfunction{predictCoding} is a \Robject{DataFrame} with 
one row for each variant-transcript match. Unlike \Rfunction{locateVariants}, 
this function only returns results for the variants that fall in a coding 
region. 

<<predictCoding>>=
library(BSgenome.Hsapiens.UCSC.hg19)
aacoding <- predictCoding(query=vcf, subject=txdb19, seqSource=Hsapiens)
head(aacoding, 4)
@

If translation was possible, the value in the consequence column will be 
`synonymous' or `nonsynonymous'. Where translation was not possible, 
consequence will be `frameshift' and the \Robject{varAA} value will be missing. 

<<predictCoding_frameshift>>=
## consequence is 'frameshift' where translation is not possible
head(aacoding[width(aacoding$varAA) == 0,], 4)
@

\section{SIFT and PolyPhen Databases}

From \Rfunction{predictCoding} we identified the amino acid coding changes for 
the non-synonymous variants. For this subset of variants we retrieve predictions 
of how damaging these coding changes may be. SIFT (Sorting Intolerant From 
Tolerant) and PolyPhen (Polymorphism Phenotyping) are methods that predict the 
impact of amino acid substitution on a human protein. The SIFT method uses 
sequence homology and the physical properties of amino acids to make predictions 
about protein function. PolyPhen uses sequence-based features and structural 
information characterizing the substitution to make predictions about the 
structure and function of the protein. 

Collated predictions for specific dbSNP builds are available as downloads from 
the SIFT and PolyPhen web sites. These results have been packaged into
\Rpackage{SIFT.Hsapiens.dbSNP132.db} and \Rpackage{PolyPhen.Hapiens.dbSNP131.db} 
and are designed to be searched by rsid. Variants that are in dbSNP can be 
searched with these database packages. When working with novel variants, SIFT
and PolyPhen must be called directly. See references for home pages.

We identify the non-synonymous variants and obtain the rsids.
<<nonsynonymous>>=
nonsyn <- with(aacoding, unique(queryID[consequence == "nonsynonymous"]))
nonsyn

nms <- names(rd[nonsyn])
rsids <- nms[grep("rs", nms, fixed=TRUE)]
rsids
@

Detailed descriptions of the database columns can be found with
\Rcode{?SIFTDbColumns} and \Rcode{?PolyPhenDbColumns}. Variants in these
databases often contain more than one row per variant. The variant may have
been reported by multiple sources and therefore the source will differ as well
as some of the other variables. 

<<sift>>=
library(SIFT.Hsapiens.dbSNP132)

## rsids in the package 
head(keys(SIFT.Hsapiens.dbSNP132))

## list available columns
cols(SIFT.Hsapiens.dbSNP132)

## select a subset of columns
## a warning is thrown when a key is not found in the database
subst <- c("RSID", "PREDICTION", "SCORE", "AACHANGE", "PROTEINID")
sift <- select(SIFT.Hsapiens.dbSNP132, keys=rsids, cols=subst)
head(sift)
@

Next we query the PolyPhen database for information on these variants.
The PolyPhen dataset is for dbSNP build 131 and we see it does not include
all of the variants. PolyPhen provides predictions using two different
training datasets and has considerable information about 3D protein structure. 
See \Rcode{?PolyPhenDbColumns} or the PolyPhen web site listed in the
references for more details.
<<polyphen>>=
library(PolyPhen.Hsapiens.dbSNP131)
pp <- select(PolyPhen.Hsapiens.dbSNP131, keys=rsids, 
         cols=c("TRAININGSET", "PREDICTION", "PPH2PROB", "AA1", "AA2"))
head(pp)
@

\section{Other operations}
\subsection{Create a SnpMatrix}

The 'GT' element in the \Rcode{FORMAT} field of the VCF represents the 
genotype. These data can be converted into a \Robject{snpMatrix} object 
which can then be used with the functions offered in \Rpackage{snpStats} 
and other packages making use of the \Robject{SnpMatrix} class. 

The \Rfunction{MatrixToSnpMatrix} function converts the genotype calls in
\Rcode{geno} to a \Robject{SnpMatrix}. No dbSNP package is used in this
computation. The return value is a named list where 'genotypes' is a 
\Robject{SnpMatrix} and 'map' is a \Robject{DataFrame} with SNP names and 
alleles at each loci. The \Rcode{ignore} column in 'map' indicates which 
variants were set to NA (missing) because they met one or more of the following 
criteria,
\begin{itemize}
\item{only diploid calls are included; others are set to NA}
\item{only single nucleotide variants are included; others are set to NA}
\item{variants with >1 ALT allele are set to NA}
\end{itemize}

See ?\Rfunction{MatrixToSnpMatrix} for more details.

<<snpMatrix>>=
calls <- geno(vcf)$GT
a0 <- values(ref(vcf))[["REF"]]
a1 <- values(alt(vcf))[["ALT"]] 

res <- MatrixToSnpMatrix(calls, a0, a1)
res
@

The \Rcode{ALT} value in the 'map' \Robject{DataFrame} will be a
\Robject{CharacterList} if the VCF was for structural variants or a 
\Robject{DNAStringSetList} otherwise. The column is not clearly visable inside 
the \Robject{DataFrame} but can be extracted and inspected as follows,
<<snpMatrix_ALT>>=
allele2 <- res$map[["allele.2"]]
## number of alternate alleles per variant
unique(elementLengths(allele2))
unlist(allele2)
@

\subsection{Expanded GRanges - under construction}

The fields in the INFO and FORMAT fields of a VCF file can have more than 
one value per variant. In the \Robject{VCF} object created by 
\Rfunction{readVcf} elements with multiple values are represented as compressed 
lists or arrays.

It may be useful to have an expanded form of the data where each
row represents a variant with a single value. This can be accomplished by
setting an option in the \Robject{ScanVcfParam} object.

Specify the \Rcode{asGRanges} argument as 'info' for an expanded 
\Robject{GRanges} with the INFO data
<<expand_info, eval=FALSE>>=
param <- ScanVcfParam(asGRanges="info")
iflat <- readVcf(vcffile, "hg19", param)
head(iflat)
@

and 'geno' for expanded genotype data.
<<expand_geno, eval=FALSE>>=
param <- ScanVcfParam(asGRanges="geno")
gflat <- readVcf(vcffile, "hg19", param)
@

\subsection{Write out VCF files - under construction}

\section{References}
Wang K, Li M, Hakonarson H, (2010), ANNOVAR: functional annotation of genetic 
variants from high-throughput sequencing data. Nucleic Acids Research, Vol 38,
No. 16, e164.\\

\noindent McLaren W, Pritchard B, RiosD, et. al., (2010), Deriving the consequences of
genomic variants with the Ensembl API and SNP Effect Predictor. Bioinformatics,
Vol. 26, No. 16, 2069-2070.\\

\noindent SIFT home page :
\url{http://sift.bii.a-star.edu.sg/}\\

\noindent PolyPhen home page :
\url{http://genetics.bwh.harvard.edu/pph2/}

\section{Session Information}
<<sessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
