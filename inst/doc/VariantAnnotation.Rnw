%\VignetteIndexEntry{Introduction to VariantAnnotation}
%\VignetteDepends{GenomicRanges, Rsamtools, Biostrings, AnnotationDbi, BSgenome}
%\VignetteKeywords{variants, sequence, sequencing, alignments}
%\VignettePackage{VariantAnnotation}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\VariantAnnotation}{\Rpackage{VariantAnnotation}}

\title{Introduction to \VariantAnnotation}
\author{Valerie Obenchain, Michael Lawrence}
\date{\today}

\begin{document} 

\maketitle

<<options, echo=FALSE>>=
options(width=72)
@

\section{Introduction}
This vignette demonstrates a general workflow for annotating and filtering 
genetic variants using the \VariantAnnotation  package. Sample data are in 
the form of a Variant Call Format (VCF) file which are parsed into a 
\Rfunction{VCF} object. The \Rfunction{locateVariants} function categorizes
the variants with respect to gene function, such as 'intron', 'coding', 'UTR' 
or 'intergenic'. Amino acid coding changes for the non-synonymous variants
can be computed with \Rfunction{predictCoding}. Subsequently, the SIFT and 
PolyPhen databases can be queried to provide predictions of how severly these
amino acid coding changes may affect protein function. Filtering functions 
allow the subsetting of variants on physical location in the gene or membership 
in dbSNP. 

\section{Reading Variant Call Format (VCF) files}
\subsection{Accessing the data}
The sample data are a subset of 1000 variants and 50 samples from chromosome 22
from 1000 Genomes,
\url{ftp://ftp-trace.ncbi.nih.gov/1000genomes/ftp/release/20110521/}.

<<readVcf>>=
library(VariantAnnotation)
vcffile <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
vcf <- readVcf(vcffile, "hg19")
@

Data are parsed into a \Robject{VCF} object. The header information from the
VCF file is stored as a \Robject{SimpleList} in the \Rcode{exptData} slot and 
can be viewed by querying elements of the list.

<<readVCF_show>>=
vcf
exptData(vcf)[["HEADER"]]
exptData(vcf)[["HEADER"]][["META"]]
@

The CHROM, POS, and ID fields of the VCF file are used to create a 
\Robject{GRanges} object which is stored in the \Rcode{rowData} slot. 
<<readVCF_rowData>>=
head(rowData(vcf))
@

The REF, ALT, QUAL and FILTER fields can be accessed together with 
\Rcode{fixedFields} or individually with \Rcode{ref}, \Rcode{alt}, 
\Rcode{qual} and \Rcode{filt}. 
<<readVCF_fixed>>=
head(fixedFields(vcf), 3)
head(ref(vcf), 3)
head(alt(vcf), 3)
@

The \Robject{ALT} column is stored as a \Robject{DNAStringSetList} unless
the file is a structural VCF, in which case it is stored as a 
\Robject{CharacterList}. To take a closer look at \Robject{ALT} we extract 
it from the \Robject{GRanges} and determine the number of elements in the
list. In this case we have only 1 alternate allele value per variant.
<<readVCF_ALT>>=
alternate <- values(alt(vcf))[["ALT"]]
alternate

## number of ALT values per variant
unique(elementLengths(alternate))
unlist(alternate)
@

Data from the \Rcode{INFO} field can be accessed with \Rcode{info}. Detailed
information about each of the \Rcode{INFO} fields from the VCF header can be 
accessed with \Rfunction{exptData}. To view all of REF, ALT, QUAL, FILTER and 
INFO together use the \Rfunction{fixed} accessor. Note the distinction between
the \Rfunction{fixedFields} and \Rfunction{fixed} accessors. The first returns 
REF, ALT, QUAL and FILTER fields while the second also returns INFO. 
<<readVCF_info>>=
## header information related to the INFO fields
head(exptData(vcf)[["HEADER"]][["INFO"]], 3)

## just the INFO data
info(vcf)[1:3, 1:3]

## all fixed fields
fixed(vcf)[1:3, 1:7] 
@

The genotype data described in the \Rcode{FORMAT} fields is parsed into 
matrices or arrays and can be accessed with \Rcode{geno}. These data
are not returned with the \Robject{GRanges} from the \Rcode{rowData}
slot because the data structures may be multidimentional.
<<readVCF_geno>>=
## header information related to the genotype fields
exptData(vcf)[["HEADER"]][["FORMAT"]]
geno(vcf)
geno(vcf)$GT[1:3,1:5]
geno(vcf)$DS[1:3,1:5]
@

\subsection{Reading in subsets of data}
When the \Rcode{param} argument to \Rfunction{readVcf} is not specified the 
entire file is read in was the case in our previous example. When working 
with large VCF files or when interested in only a portion of the data it may be 
more efficient to read in subsets of the data. Subsets can be specified as 
ranges and/or elements in the \Rcode{INFO} or \Rcode{FORMAT} fields from the VCF 
file. 

\subsubsection{Subset on ranges}
Specifying range subsets can be accomplished by specifying the \Rcode{which} 
argument of a \Rcode{ScanVcfParam} object or by providing a \Robject{GRanges}, 
\Robject{RangedData} or \Robject{RangesList} as the \Rcode{param} argument.

Tabix index file :\\
\noindent When ranges are specified, the VCF file must have an accompanying 
Tabix index file; if one does not exist it must be created. See 
?\Rcode{indexTabix} for help creating an index file. An index file is only 
necessary when subsetting the data by ranges. If the full file is to be read 
or if the data are being subset only on \Rcode{INFO} or \Rcode{FORMAT} subsets 
then an index file is not necessary.

TabixFile Object :\\
\noindent Once a Tabix index exists for the VCF file, we can create a
\Robject{TabixFile} object. See ?\Rcode{TabixFile}. This object creates
a reference to the VCF and its index. Once opened, the reference remains
open across calls to methods, avoiding costly index re-loading. 

\noindent Note that the \Rcode{file} argument to \Rfunction{readVcf} can be either a 
\Rcode{character} name of the file or a \Robject{TabixFile} instance. When 
a \Rcode{character} name is provided it will be coerced to a \Robject{TabixFile}
and if no Tabix index file is found an error will be thrown.

Our sample file has an index file which enables us to create a \Rcode{TabixFile} 
instance. 
<<readVCF_tabix>>=
## create a TabixFile instance
tab <- TabixFile(vcffile)
rng <- GRanges(seqnames="22", ranges=IRanges(start=51151293, end=51152761))

## call the method with either the filename or TabixFile
vcf_fl_rng <- readVcf(vcffile, "hg19", param=rng)
vcf_tab_rng <- readVcf(tab, "hg19", param=rng)
identical(vcf_fl_rng, vcf_tab_rng)
@

In the previous example ranges were specified as a \Robject{GRanges} object.
Here we put the ranges in a \Robject{ScanVcfParam} and see the results are 
equivalent.

<<readVCF_ranges>>=
svp <- ScanVcfParam(which=rng)
vcf_fl_svp <- readVcf(vcffile, "hg19", param=svp)
identical(vcf_fl_rng, vcf_fl_svp)
@

%% FIXME: read in genes in chr22

\subsubsection{Subset on INFO and FORMAT elements}
A subset of data can be read in based on the elements in the \Rcode{INFO} and / 
or \Rcode{FORMAT} fields of the VCF file. Elements are provided as a
\Rcode{character} vector in the \Rcode{info} and \Rcode{geno} arguments to 
\Rcode{ScanVcfParam}. Currently there is no way to filter the incoming data
on a particular value of a \Rcode{INFO} or \Rcode{FORMAT} element. That may be
a feature added in the future. 

In the previous section we saw that a Tabix index file must exist when data are
subset on ranges. This is not the case when subsetting on elements in the
\Rcode{INFO} and \Rcode{FORMAT} fields. An index file is only needed when
subsetting by ranges.

<<readVCF_infogeno, eval=FALSE>>=
## view available INFO and FORMAT fields
hdr <- scanVcfHeader(vcffile)[[1]]$Header
hdr$INFO
hdr$FORMAT

## subset on INFO and FORMAT
param <- ScanVcfParam(geno="GT", info="LDAF")
vcf <- readVcf(vcffile, "hg19", param)

## subset on ranges and INFO and FORMAT
param <- ScanVcfParam(geno="GT", info="LDAF", which=rng)
vcf <- readVcf(vcffile, "hg19", param) 
@


\section{Variant location with respect to gene function}
The \Rfunction{locateVariants} function matches ranges in a \Robject{GRanges}
object to the coding, intron and UTR regions in a \Robject{TranscriptDb}. 
Metadata columns may be present in the \Robject{GRanges} but they are ignored.

The variant ranges come from the \Rcode{rowData} slot in the \Robject{VCF} 
object. As a preliminary step, we must ensure the chromosome names in our ranges 
are compatible with those in the \Robject{TranscriptDb}.

Chromosome names are represented by the number only, i.e. '22', in the
variant ranges
<<seqlevels_rd>>=
rd <- rowData(vcf)
seqlevels(rd)
@

but are preceeded by 'chr' in the TxDb.
<<seqlevels_TxDb>>=
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb19 <- TxDb.Hsapiens.UCSC.hg19.knownGene 
head(seqlevels(txdb19))
@

We rename the seqlevels in the \Robject{VCF} object to match the TxDb.
Modifying the chromosome names at the \Robject{VCF}-level ensures all 
future data extractions from the \Robject{VCF} will have the new 
seqlevels. Helper functions for renaming and subsetting seqlevels are 
\Rfunction{renameSeqlevels} and \Rfunction{keepSeqlevels}.
<<seqlevels_rename>>=
## rename variant seqlevels in the VCF object
rd_mod <- renameSeqlevels(rd, c("22"="chr22"))
rowData(vcf) <- rd_mod 

## extract the modified rowData
rd <- rowData(vcf)
 
## confirm seqlevels are the same
intersect(seqlevels(rd), seqlevels(txdb19))
@

Our sample data has ranges for chromosome 22 only so there is no need
for further subsetting. However, if we had additional chromosomes we
wanted to drop we could subset a \Robject{GRanges} using 
\Rfunction{keepSeqlevels}. As an example we extract transcripts for
all chromosomes in TxDb.Hsapiens.UCSC.hg19.knownGene then keep only 
'chr21' and 'chr22'. 
\begin{verbatim}
## initially there are 93 chromosomes
> rngs <- transcripts(txdb19)
> length(seqlevels(rngs))
[1] 93
## keep only chr21 and chr22 
> rngs <- keepSeqlevels(rngs, c("chr21", "chr22"))
> seqlevels(rngs)
[1] "chr21" "chr22"
\end{verbatim}

Call \Rfunction{locateVariants},
\begin{verbatim}
> loc <- locateVariants(rd, txdb19)
> loc[515:605,]
DataFrame with 91 rows and 4 columns
    queryHits      txID                    geneID   Location
    <integer> <integer> <CompressedCharacterList>   <factor>
1         249     73653                     85358      3'UTR
2         250     73651                     85358     coding
3         250     73653                     85358     coding
4         251     73651                     85358     coding
5         251     73653                     85358     coding
6         252        NA                  85358,49 intergenic
7         253        NA                  85358,49 intergenic
8         254        NA                  85358,49 intergenic
9         255        NA                  85358,49 intergenic
...       ...       ...                       ...        ...
83        329     73654                               intron
84        330     73654                               intron
85        331     73654                               intron
86        332     73654                               intron
87        333        NA                  85358,49 intergenic
88        334        NA                  85358,49 intergenic
89        335        NA                  85358,49 intergenic
90        336     73655                        49      5'UTR
91        336     73656                        49      5'UTR

\end{verbatim}

\Rfunction{locateVariants} returns a \Robject{DataFrame} with 4 columns. The
\Rcode{queryHits} column maps back to the row number in the original 
\Robject{GRanges} of variants. Each row represents a variant-transcript overlap 
and so multiple rows per variant are possible. Location categories of `coding', 
`5'UTR', `3'UTR', `intron' and `intergenic' are assigned based on the criteria 
in Table \ref{table:location}. Intergenic variants will have gene IDs for both
preceding and following genes.

Each variant has the potential to match multiple transcripts and the output 
from \Rfunction{locateVariants} can be large. Further processing may
be necessary to better understand the data. A first step might be to summarize
'Location' by gene while accounting for the variants that hit multiple 
transcripts in the same gene.

%% FIXME : modify example 
\begin{verbatim}
> single <- loc[elementLengths(loc$geneID) == 1, ]
> genes <- data.frame(queryHits=single$queryHits, geneID=unlist(single$geneID), 
+                     Location=single$Location)
> dups <- duplicated(genes)
> genesLst <- split(genes$Location[!dups], genes$geneID[!dups]) 
> lapply(genesLst, table)
$`11158`

     3'UTR      5'UTR     coding intergenic     intron 
        18          3          7          0        178 

$`284942`

     3'UTR      5'UTR     coding intergenic     intron 
        18          3          7          0        362 

$`49`

     3'UTR      5'UTR     coding intergenic     intron 
         4          1         16          0         85 

$`85358`

     3'UTR      5'UTR     coding intergenic     intron 
         5          0         23          0        223 

\end{verbatim}

\begin{table}[ht]
\begin{center}
\begin{tabular}{l|l}
\hline
Region & Details \\
\hline
coding &  variant falls \emph{within} a coding region \\
5'UTR &  variant falls \emph{within} a 5' untranslated region \\
3'UTR &  variant falls \emph{within} a 3' untranslated region \\
intron &  variant falls \emph{within} a transcript but not \emph{within} a 
coding region \\
intergenic & variant does not fall \emph{within} a transcript but does have
a nearest gene match\\
transcript\_region & variant falls \emph{within} a transcript but does not 
fall \emph{within} a specified region\\
NA & variant does not fall \emph{within} a transcript and has no
nearest gene match \\
NA & variant is on a chromosome present in \Robject{query} but not in the 
\Robject{subject}\\
\hline
\end{tabular}
\end{center}
\caption{Location of variants with respect to genes}
\label{table:location}
\end{table}

Summarize Location for all variant-transcript matches.
\begin{verbatim}
> table(loc$Location)

     3'UTR      5'UTR     coding intergenic     intron 
       215         32        168        211       3092 
\end{verbatim}

\section{Amino acid coding changes}

\Rfunction{predictCoding} provides amino acid coding changes for non-synonymous 
variants. This function identifies overlaps between the variants in 
\Robject{query} and the coding regions of a \Robject{TranscriptDb} object. 
Sequences for the reference codons are retrieved from either a \Robject{BSgenome} 
or fasta file. Codon sequences for the variants are constructed by substituting, 
inserting or deleting the values in the \Robject{varAllele} column into the 
reference sequence. Amino acid codes are computed for the resulting variant codon 
sequence when the length is a multiple of 3. Examples of various coding 
situations are shown in Table \ref{table:aacoding}. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{l|l|l|l|l|c}
\hline
Type & refAllele & varAllele & refSeq & varSeq & translation possible \\
\hline
substitution & G & T & aag & aaT & yes\\
substitution & G & TG & tga & tTGa & no\\
substitution & G & TGCG & gtc & TGCGtc & yes\\
insertion & `' & G & cgg & Gcgg & no\\
insertion & `' & TTG & gaa & gaTTGa & yes\\
deletion & A & `' & atc & tc & no\\
deletion & GGCCTA & `' & acggcctaa & aca & yes\\
\hline
\end{tabular}
\end{center}
\caption{Amino acid coding changes}
\label{table:aacoding}
\end{table}

\Rfunction{predictCoding} will accept either a \Robject{TranscriptDb} or a 
\Robject{GRangesList} as the \Rcode{subject}. When a \Robject{TranscriptDb} 
is supplied the approprate \Robject{GRangesList} is created by calling the 
\Rfunction{cdsBy} function. If a \Robject{GRangesList} is supplied it is 
assumed that it was created with \Rfunction{cdsBy} or has been put
into the same format as the output from that function. In other words, the 
outer list elements must define coding regions and the individual elements 
fall within that coding region. 

The \Robject{query} argument can be a \Robject{GRanges} or \Robject{VCF}.
When a \Robject{GRanges} is supplied it must have a elementMetadata column
that contains the variant (alternate) alleles as a \Robject{DNAStringSet}.
The name of this column is provideed as the \Robject{varAllele} argument.
When the \Robject{query} is a \Robject{VCF} object no \Robject{varAllele}
argument is necessary.

We use a \Robject{BSgenome} as our sequence source but could have also used
an appropriate fasta file.

<<predictCoding>>=
library(BSgenome.Hsapiens.UCSC.hg19)
aacoding <- predictCoding(query=vcf, subject=txdb19, seqSource=Hsapiens)
@

\Robject{predictCoding} returns a \Robject{DataFrame} with one row for each 
variant-transcript match. Unlike \Rfunction{locateVariants}, this function 
only returns results for the variants that fall in a coding region. The 
\Robject{queryID} column is the map back to the variants in the original 
\Robject{query}. If translation was possible, the consequence value will be 
`synonymous' or `nonsynonymous'. Where translation was not possible, 
consequence will be `frameshift' and the varAA value will be missing. 

<<aacoding_notranslation>>= 
head(aacoding, 4)

## consequence is 'frameshift' where translation is not possible
head(aacoding[width(aacoding$varAA) == 0,], 4)
@

\section{Filtering}

Often it is useful to identify subsets of variants that meet a specific 
criteria. There are currently two built-in filters available in
\Rpackage{VariantAnnotation}. The \Rfunction{dbSNPfilter} checks for membership 
in dbSNP and \Rfunction{regionFilter} filters variants based on the locations 
identified with\Rfunction{locateVariants}. Filters are created with the 
appropriate reference object such as a \Robject{SNPlocs} or 
\Robject{TranscriptDb} object. 

<<createFilters>>=
## create filter to identify variants present in dbSNP 
library("SNPlocs.Hsapiens.dbSNP.20110815")
snpFilt <- dbSNPFilter("SNPlocs.Hsapiens.dbSNP.20110815")
vaFilter(snpFilt)

## create filter to identify variants present in introns 
regionFilt <- regionFilter(txdb19, region="intron")
vaFilter(regionFilt)
@

When filtering data with \Rfunction{dbSNPFilter} or \Rfunction{regionsFilt} two 
options are available for the return object. If the argument \Rcode{subset=TRUE}
(default) a \Robject{GRanges} is returned that contains only the records that
passed the filter. If \Rcode{subset=FALSE}, the result is a 
\Robject{VAFilterResult} object. This object contains a logical vector 
indicating which records passed the filter and some statistics on the number of 
records removed and what filter was applied. 

First we return the subset of variants that are in dbSNP. Again, the variant 
seqlevels need to be adjusted to match the seqlevels of the annotation.
<<filtering>>=
## return the subset of records that passed the filter
rd <- rowData(vcf)
seqlevels(rd) <- paste("ch", seqlevels(rd), sep="")
dbsnp <- snpFilt(rd)
summary(dbsnp) 
metadata(dbsnp)

## return a VAFilterResult object
snpFilt(rd, subset=FALSE)
@

Next we identify the variants that fall in an intron region.
\begin{verbatim}
> rd <- rowData(vcf)
> seqlevels(rd) <- paste("chr", seqlevels(rd), sep="")
> intron <- regionFilt(rd)
> summary(intron)
 Length   Class    Mode 
    712 GRanges      S4 
\end{verbatim}

\section{SIFT and PolyPhen Databases}

From \Rfunction{predictCoding} we identified the amino acid coding changes for 
the non-synonymous variants. For this subset of variants we retrieve predictions 
of how damaging these coding changes may be. SIFT (Sorting Intolerant From 
Tolerant) and PolyPhen (Polymorphism Phenotyping) are methods that predict the 
impact of amino acid substitution on a human protein. The SIFT method uses 
sequence homology and the physical properties of amino acids to make predictions 
about protein function. PolyPhen uses sequence-based features and structural 
information characterizing the substitution to make predictions about the 
structure and function of the protein. 

Collated predictions for specific dbSNP builds are available as downloads from 
the SIFT and PolyPhen web sites. These results have been packaged into
\Rpackage{SIFT.Hsapiens.dbSNP132.db} and \Rpackage{PolyPhen.Hapiens.dbSNP131.db} 
and are designed to be searched by rsid.

We identify the non-synonymous variants and obtain the rsids.
<<nonsynonymous>>=
nonsyn <- with(aacoding, unique(queryID[consequence == "nonsynonymous"]))
nonsyn

nms <- names(rd[nonsyn])
rsids <- nms[grep("rs", nms, fixed=TRUE)]
rsids
@

Detailed descriptions of the database columns can be found with
\Rcode{?SIFTDbColumns} and \Rcode{?PolyPhenDbColumns}. Variants in these
databases often contain more than one row per variant. The variant may have
been reported by multiple sources and therefore the source will differ as well
as some of the other variables. 

<<sift>>=
library(SIFT.Hsapiens.dbSNP132)

## rsids in the package 
head(keys(SIFT.Hsapiens.dbSNP132))

## list available columns
cols(SIFT.Hsapiens.dbSNP132)

## select a subset of columns
## a warning is thrown when a key is not found in the database
subst <- c("RSID", "PREDICTION", "SCORE", "AACHANGE", "PROTEINID")
sift <- select(SIFT.Hsapiens.dbSNP132, keys=rsids, cols=subst)
head(sift)
@

Next we query the PolyPhen database for information on these variants.
The PolyPhen dataset is for dbSNP build 131 and we see it does not include
all of the variants. PolyPhen provides predictions using two different
training datasets and has considerable information about 3D protein structure. 
See \Rcode{?PolyPhenDbColumns} or the PolyPhen web site listed in the
references for more details.
<<polyphen>>=
library(PolyPhen.Hsapiens.dbSNP131)
pp <- select(PolyPhen.Hsapiens.dbSNP131, keys=rsids, 
         cols=c("TRAININGSET", "PREDICTION", "PPH2PROB", "AA1", "AA2"))
head(pp)
@

\section{Extras}
\subsection{Creating a SnpMatrix object}

The 'GT' element in the \Rcode{FORMAT} field of the VCF represents the 
genotype. These data can be converted into a \Robject{snpMatrix} object 
which can then be used with the functions offered in \Rpackage{snpStats} 
and other packages making use of the \Robject{SnpMatrix} class. 

The \Rfunction{MatrixToSnpMatrix} function converts the genotype calls in
\Rcode{geno} to a \Robject{SnpMatrix}. No dbSNP package is used in this
computation. The return value is a named list where 'genotypes' is a 
\Robject{SnpMatrix} and 'map' is a \Robject{DataFrame} with SNP names and 
alleles at each loci. The \Rcode{ignore} column in 'map' indicates which 
variants were set to NA (missing) because they met one or more of the following 
criteria,
\begin{itemize}
\item{only diploid calls are included; others are set to NA}
\item{only single nucleotide variants are included; others are set to NA}
\item{variants with >1 ALT allele are set to NA}
\end{itemize}

See ?\Rfunction{MatrixToSnpMatrix} for more details.

<<snpMatrix>>=
calls <- geno(vcf)$GT
a0 <- values(ref(vcf))[["REF"]]
a1 <- values(alt(vcf))[["ALT"]] 

res <- MatrixToSnpMatrix(calls, a0, a1)
res
@

The \Rcode{ALT} value in the 'map' \Robject{DataFrame} will be a
\Robject{CharacterList} if the VCF was for structural variants or a 
\Robject{DNAStringSetList} otherwise. The column is not clearly visable inside 
the \Robject{DataFrame} but can be extracted and inspected as follows,
<<snpMatrix_ALT>>=
allele2 <- res$map[["allele.2"]]
## number of alternate alleles per variant
unique(elementLengths(allele2))
unlist(allele2)
@

\section{References}
Wang K, Li M, Hakonarson H, (2010), ANNOVAR: functional annotation of genetic 
variants from high-throughput sequencing data. Nucleic Acids Research, Vol 38,
No. 16, e164.\\

\noindent McLaren W, Pritchard B, RiosD, et. al., (2010), Deriving the consequences of
genomic variants with the Ensembl API and SNP Effect Predictor. Bioinformatics,
Vol. 26, No. 16, 2069-2070.\\

\noindent SIFT home page :
\url{http://sift.bii.a-star.edu.sg/}\\

\noindent PolyPhen home page :
\url{http://genetics.bwh.harvard.edu/pph2/}

\section{Session Information}
<<sessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
